{"data": "\n/* Comment generated by Gradeer\nSource files of AbdallahKayed: \n- /uk/ac/sheffield/com1003/assignment/FootieDashboard.java: \n- /uk/ac/sheffield/com1003/assignment/PlayerCatalog.java: \n- /uk/ac/sheffield/com1003/assignment/codeprovided/AbstractQueryParser.java: \n- /uk/ac/sheffield/com1003/assignment/codeprovided/PlayerEntry.java: \n- /uk/ac/sheffield/com1003/assignment/codeprovided/SubQuery.java: \n- /uk/ac/sheffield/com1003/assignment/codeprovided/PlayerProperty.java: \n- /uk/ac/sheffield/com1003/assignment/codeprovided/Category.java: \n- /uk/ac/sheffield/com1003/assignment/codeprovided/PlayerDetail.java: \n- /uk/ac/sheffield/com1003/assignment/codeprovided/League.java: \n- /uk/ac/sheffield/com1003/assignment/codeprovided/Query.java: \n- /uk/ac/sheffield/com1003/assignment/codeprovided/gui/AbstractRadarChartPanel.java: \n- /uk/ac/sheffield/com1003/assignment/codeprovided/gui/PlayerEntryDashboard.java: \n- /uk/ac/sheffield/com1003/assignment/codeprovided/gui/AbstractPlayerDashboardPanel.java: \n- /uk/ac/sheffield/com1003/assignment/codeprovided/gui/AbstractRadarChart.java: \n- /uk/ac/sheffield/com1003/assignment/codeprovided/gui/RadarAxisValues.java: \n- /uk/ac/sheffield/com1003/assignment/codeprovided/PlayerPropertyMap.java: \n- /uk/ac/sheffield/com1003/assignment/codeprovided/AbstractPlayerCatalog.java: \n- /uk/ac/sheffield/com1003/assignment/QueryParser.java: \n- /uk/ac/sheffield/com1003/assignment/gui/PlayerDashboardPanel.java: \n- /uk/ac/sheffield/com1003/assignment/gui/RadarChart.java: \n- /uk/ac/sheffield/com1003/assignment/gui/RadarChartPanel.java: \n*/\n\n\n/* Comment generated by Gradeer\n==============\nFootieDashboard.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport uk.ac.sheffield.com1003.assignment.codeprovided.*;\nimport uk.ac.sheffield.com1003.assignment.codeprovided.gui.AbstractPlayerDashboardPanel;\nimport uk.ac.sheffield.com1003.assignment.codeprovided.gui.PlayerEntryDashboard;\nimport uk.ac.sheffield.com1003.assignment.gui.PlayerDashboardPanel;\n\n/**\n * Main class to run the Assignment's graphical user interface\n *\n * @version 1.1  09/03/2023\n *\n * @author Maria-Cruz Villa-Uriol\n * @author Ben Clegg\n *\n * Copyright (c) University of Sheffield 2023\n */\n\npublic class FootieDashboard {\n\n\tprivate final AbstractPlayerCatalog playerCatalog;\n\tprivate final List<Query> queries;\n\n\t/**\n\t * Main method - receives two CSV files with the relevant player entries data and a text file\n\t * with relevant query data.\n\t *\n\t * @param args two CSV files and a text file with queries defined by the user\n\t */\n\tpublic static void main(String[] args) {\n\t\tif (args.length == 0) {\n\t\t\targs = new String[]{\n\t\t\t\t\t\"src/main/resources/epl-2223.csv\",\n\t\t\t\t\t\"src/main/resources/laliga-2223.csv\",\n\t\t\t\t\t\"src/main/resources/queries.txt\"};\n\t\t}\n\t\tString eplFile = args[0];\n\t\tString ligaFile = args[1];\n\t\tString queriesFile = args[2];\n\n\t\tFootieDashboard footieDashboard =\n\t\t\t\tnew FootieDashboard(eplFile, ligaFile, queriesFile);\n\n\t\tfootieDashboard.startCLI();\n\t\tfootieDashboard.startGUI();\n\t}\n\n\tpublic FootieDashboard(String eplFile, String ligaFile, String queriesFile) {\n\t\tplayerCatalog = new PlayerCatalog(eplFile, ligaFile);\n\t\tList<String> queryTokens = new ArrayList<>(AbstractQueryParser.readQueryFile(queriesFile));\n\t\tqueries = new ArrayList<>(new QueryParser().readQueries(queryTokens));\n\t}\n\n\t/**\n\t * Start the simple CLI based portion of the assignment\n\t */\n\tpublic void startCLI() {\n\t\t// Basic player catalogue information\n\t\tprintNumberUniquePlayers();\n\t\tprintQuestionAnswers();\n\t\tprintFirstFivePlayerEntries();\n\n\t\t// Queries\n\t\tprintNumberQueries();\n\t\texecuteQueries();\n\t}\n\n\t/**\n\t * Display the number of unique players for whole dataset, and number of player entries\n\t * for EPL and LIGA datasets\n\t */\n\tprivate void printNumberUniquePlayers() {\n\t\tSystem.out.print(\"The number of unique players in both leagues is: \");\n\t\tSystem.out.println(playerCatalog.getNumberUniquePlayers(League.ALL));\n\t\tSystem.out.println();\n\n\t\tSystem.out.print(\"The total number of English Premier League player entries in the dataset is: \");\n\t\tSystem.out.println(playerCatalog.getNumberPlayerEntries(League.EPL));\n\t\tSystem.out.println();\n\n\t\tSystem.out.print(\"The total number of La Liga players in the dataset is: \");\n\t\tSystem.out.println(playerCatalog.getNumberPlayerEntries(League.LIGA));\n\t\tSystem.out.println();\n\t}\n\n\t/**\n\t * Print the answers to the questions defined in the specification\n\t */\n\tprivate void printQuestionAnswers() {\n\t\tSystem.out.println(\"The highest number of assists in the Premier League is \" +\n\t\t\t\tplayerCatalog.getMaximumValue(PlayerProperty.ASSISTS, League.EPL));\n\t\tSystem.out.println();\n\n\t\tSystem.out.println(\"The highest number of fouls committed in La Liga is \" +\n\t\t\t\tplayerCatalog.getMaximumValue(PlayerProperty.FOULSCOMMITTED, League.LIGA));\n\t\tSystem.out.println();\n\n\t\tSystem.out.println(\"The average number of shots on target across the Premier League and La Liga is  \" +\n\t\t\t\tplayerCatalog.getMeanAverageValue(PlayerProperty.SHOTSTARGET, League.ALL));\n\t\tSystem.out.println();\n\t}\n\n\t/**\n\t * Print the number of Queries (not SubQueries) identified in the queries file\n\t */\n\tprivate void printNumberQueries() {\n\t\t// Prints results from queries by calling relevant methods\n\t\tSystem.out.println(\"In total, \" + queries.size() + \" queries were found.\");\n\t\tSystem.out.println();\n\t}\n\n\t/**\n\t * Execute each query; displaying the filtered players for each query\n\t */\n\tprivate void executeQueries() {\n\t\tSystem.out.println(\"Executing queries...\");\n\n\t\tfor (Query query : queries) {\n\t\t\tSystem.out.println(query.toString() + \":\");\n\t\t\tList<PlayerEntry> queryResults = query.executeQuery(playerCatalog);\n\t\t\tprintPlayerEntries(queryResults);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\t/**\n\t * Display the provided players\n\t * @param playerEntries the player entries to display\n\t */\n\tprivate void printPlayerEntries(Collection<PlayerEntry> playerEntries) {\n\t\tint i = 0;\n\t\tfor (PlayerEntry w : playerEntries) {\n\t\t\tSystem.out.println(w.toString());\n\t\t\ti++;\n\t\t\tif (i > 4) return;\n\t\t}\n\t}\n\n\tprivate void printFirstFivePlayerEntries() {\n\t\tSystem.out.println(\"\nEnglish Premier League:\");\n\t\tprintPlayerEntries(playerCatalog.getFirstFivePlayerEntries(League.EPL));\n\n\t\tSystem.out.println(\"\nLa Liga:\");\n\t\tprintPlayerEntries(playerCatalog.getFirstFivePlayerEntries(League.LIGA));\n\t}\n\n\t/**\n\t * Start the GUI of the assignment\n\t */\n\tpublic void startGUI() {\n\t\t// Start GUI\n\t\tAbstractPlayerDashboardPanel browserPanel = new PlayerDashboardPanel(playerCatalog);\n\t\tPlayerEntryDashboard playerDashboard = new PlayerEntryDashboard(browserPanel);\n\t\tplayerDashboard.setVisible(true);\n\t}\n}\n\n/* Comment generated by Gradeer\n==============\nPlayerCatalog.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment;\n\nimport uk.ac.sheffield.com1003.assignment.codeprovided.*;\n\nimport java.util.*;\n\n/**\n * SKELETON IMPLEMENTATION\n */\npublic class PlayerCatalog extends AbstractPlayerCatalog\n{\n    /**\n     * Constructor\n     */\n    public PlayerCatalog(String eplFilename, String ligaFilename) {\n        super(eplFilename, ligaFilename);\n    }\n\n    @Override\n    public PlayerPropertyMap parsePlayerEntryLine(String line) throws IllegalArgumentException\n    {\n        PlayerPropertyMap playerProperties = new PlayerPropertyMap();\n        // Split the line into fields\n        String[] fields = line.split(\",\");\n\n        // Check that the line includes every property for a single player\n        if (fields.length != 29) {\n            throw new IllegalArgumentException(\"Invalid number of fields in line: \" + line);\n        }\n\n        // Check that the line contains valid properties and add the fields to playerProperties\n        String[] propertyNames = {\n            PlayerDetail.PLAYER.toString(),\n            PlayerDetail.NATION.toString(),\n            PlayerDetail.POSITION.toString(),\n            PlayerDetail.TEAM.toString(),\n            PlayerProperty.AGE.toString(),\n            PlayerProperty.MATCHES.toString(),\n            PlayerProperty.MINUTES.toString(),\n            PlayerProperty.YELLOWCARDS.toString(),\n            PlayerProperty.REDCARDS.toString(),\n            PlayerProperty.GOALS.toString(),\n            PlayerProperty.PKGOALS.toString(),\n            PlayerProperty.PKATTEMPTS.toString(),\n            PlayerProperty.ASSISTS.toString(),\n            PlayerProperty.OWNGOALS.toString(),\n            PlayerProperty.PASSATTEMPTED.toString(),\n            PlayerProperty.PASSCOMPLETED.toString(),\n            PlayerProperty.AERIALSWON.toString(),\n            PlayerProperty.AERIALSLOST.toString(),\n            PlayerProperty.AERIALSWONPERC.toString(),\n            PlayerProperty.TACKLES.toString(),\n            PlayerProperty.TACKLESWON.toString(),\n            PlayerProperty.CLEARANCES.toString(),\n            PlayerProperty.FOULSCOMMITTED.toString(),\n            PlayerProperty.PKCONCEDED.toString(),\n            PlayerProperty.SHOTS.toString(),\n            PlayerProperty.SHOTSTARGET.toString(),\n            PlayerProperty.FOULSDRAWN.toString(),\n            PlayerProperty.CROSSES.toString(),\n            PlayerProperty.PKWON.toString()\n        };\n        \n        for (int i = 0; i < propertyNames.length; i++) {\n            String propertyName = propertyNames[i];\n            String fieldValue = fields[i];\n            \n            // Add the PlayerDetail/PlayerProperty and value pair to playerProperties\n            if (isValidPlayerDetail(propertyName)) {\n                playerProperties.putDetail(PlayerDetail.valueOf(propertyName), fieldValue);\n            }\n            else {\n                try {\n                    double value = Double.valueOf(fieldValue);\n                    if (value >= 0) {\n                        playerProperties.put(PlayerProperty.valueOf(propertyName), value);\n                    } else {\n                        throw new IllegalArgumentException(\"Invalid \" + \n                            propertyName.toLowerCase() + \" in line: \" + line);\n                    }\n                } catch (NumberFormatException e) {\n                    throw new IllegalArgumentException(\"Invalid \" + propertyName.toLowerCase() + \n                        \" in line: \" + line);\n                }\n            }\n        }\n        \n        return playerProperties;\n    }\n\n    /**\n     * Check whether a given string represents a valid player detail.\n     *\n     * @param playerDetailToCheck the string to check\n     * @return true if the string represents a valid player detail; false otherwise\n     */\n    public boolean isValidPlayerDetail(String playerDetailToCheck) {\n        try {\n            PlayerDetail.fromName(playerDetailToCheck);\n            return true;\n        } catch (NoSuchElementException e) {\n            return false;\n        }\n    }\n\n    @Override\n    public void updatePlayerCatalog() {\n        List<PlayerEntry> eplEntries = playerEntriesMap.get(League.EPL);\n        List<PlayerEntry> ligaEntries = playerEntriesMap.get(League.LIGA);\n\n        // Create a new list containing all player entries\n        List<PlayerEntry> allLeagues = new ArrayList<>();\n        allLeagues.addAll(eplEntries);\n        allLeagues.addAll(ligaEntries);\n\n        // Add the new list to the playerEntriesMap\n        playerEntriesMap.put(League.ALL, allLeagues);\n    }\n\n    @Override\n    public double getMinimumValue(PlayerProperty playerProperty, List<PlayerEntry> playerEntryList)\n            throws NoSuchElementException {\n        if (playerEntryList.isEmpty()) {\n            throw new NoSuchElementException(\"There is no minimum value for the empty list.\");\n        }\n\n        // Find the minimum value for the given playerProperty\n        double minimumValue = Double.MAX_VALUE;\n        for (PlayerEntry playerEntry : playerEntryList) {\n            double value = playerEntry.getProperty(playerProperty);\n            if (value < minimumValue) {\n                minimumValue = value;\n            }\n        }\n        return minimumValue;\n    }\n\n    @Override\n    public double getMaximumValue(PlayerProperty playerProperty, List<PlayerEntry> playerEntryList)\n            throws NoSuchElementException {\n        if (playerEntryList.isEmpty()) {\n            throw new NoSuchElementException(\"There is no maximum value for the empty list.\");\n        }\n        \n        // Find the maximum value for the given playerProperty\n        double maximumValue = Double.MIN_VALUE;\n        for (PlayerEntry playerEntry : playerEntryList) {\n            double value = playerEntry.getProperty(playerProperty);\n            if (value > maximumValue) {\n                maximumValue = value;\n            }\n        }\n        \n        return maximumValue;\n    }\n\n    @Override\n    public double getMeanAverageValue(PlayerProperty playerProperty, List<PlayerEntry> playerEntryList)\n            throws NoSuchElementException {\n        if (playerEntryList.isEmpty()) {\n            throw new NoSuchElementException(\"There is no mean value for the empty list.\");\n        }\n        \n        // Calculate the mean value of the player property\n        double sum = 0;\n        int count = 0;\n        for (PlayerEntry playerEntry : playerEntryList) {\n            double value = playerEntry.getProperty(playerProperty);\n            sum += value;\n            count++;\n        }\n\n        double meanValue = sum / count;\n\n        return meanValue;\n    }\n\n    @Override\n    public List<PlayerEntry> getFirstFivePlayerEntries(League type)\n    {\n        List<PlayerEntry> playerEntries = getPlayerEntriesList(type);\n        return playerEntries.subList(0, 5);\n    }\n\n}\n\n/* Comment generated by Gradeer\n==============\nAbstractQueryParser.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment.codeprovided;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Abstract class to parse Queries.\n * Provides functionality to read tokens from a query file\n *\n * @version 1.0 02/03/2023\n *\n * @author Ben Clegg\n *\n * Copyright (c) University of Sheffield 2023\n */\n@SuppressWarnings(\"unused\")\npublic abstract class AbstractQueryParser\n{\n    /**\n     * Reads the queries file and splits each token in the queryFile into individual strings,\n     * (i.e. splits by spaces) and stores them in a List for further processing by the readQueries method.\n     *\n     * @param queryFile The text file containing relevant queries\n     * @return List of tokenized Strings\n     */\n    public static List<String> readQueryFile(String queryFile) {\n\n        List<String> queryTokens = new ArrayList<>();\n        String split = \" \";\n\n        try (BufferedReader br = new BufferedReader(new FileReader(queryFile))) {\n            String line = br.readLine();\n            if (line == null) {\n                throw new IllegalArgumentException(\"File is empty\");\n            }\n            while (line != null) {\n                String[] query = line.toLowerCase().split(split);\n                queryTokens.addAll(Arrays.asList(query));\n                line = br.readLine();\n            }\n\n        } catch (FileNotFoundException e) {\n            System.err.println(queryFile + \" could not be found\");\n        } catch (IOException e) {\n            System.err.println(\"File could not be handled\");\n            // enable the next line for debugging purposes\n            // e.printStackTrace();\n        }\n        return queryTokens;\n    }\n\n    /**\n     * 1 - receives the List of Strings, each is a single token\n     * 2 - assesses their content, creates the relevant Query & SubQuery objects\n     * 3 - and then returns a List of the Query objects\n     *\n     * @param queryTokens The List of tokenized Strings from the readQueryFile method\n     * @return List of all Query objects\n     * @throws IllegalArgumentException if the provided query tokens are invalid (e.g. non-numbers\n     * as boundary values, invalid operators, etc)\n     */\n    public abstract List<Query> readQueries(List<String> queryTokens) throws IllegalArgumentException;\n}\n\n/* Comment generated by Gradeer\n==============\nPlayerEntry.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment.codeprovided;\n\nimport java.util.Iterator;\n\n/**\n * Class designed to be used to create objects from player entries.\n *\n * @version 1.1  09/02/2023\n *\n * @author Maria-Cruz Villa-Uriol (m.villa-uriol@sheffield.ac.uk)\n * @author Ben Clegg\n *\n * Copyright (c) University of Sheffield 2023\n */\npublic class PlayerEntry {\n\n    private final int id;\n    private final League leagueType;\n\n    private final PlayerPropertyMap playerPropertyMap;\n\n    /**\n     * Constructor.\n     *\n     * @param id an id of the player entry; automatically generated in AbstractPlayerCatalog\n     * @param league which league\n     * @param playerPropertyMap the values of properties for each player entry (in PlayerCatalog)\n     */\n    public PlayerEntry(int id, League league, PlayerPropertyMap playerPropertyMap) {\n        this.id = id;\n        this.leagueType = league;\n        this.playerPropertyMap = playerPropertyMap;\n    }\n\n    /**\n     * Get the value of a given property of the players catalog.\n     *\n     * @param property the player property to select\n     * @return the value of the chosen player property\n     */\n    public double getProperty(PlayerProperty property) {\n        return playerPropertyMap.get(property);\n    }\n\n    /**\n     * Get the value of a given detail of the player.\n     *\n     * @param playerDetail the player detail to select\n     * @return the value of the chosen player detail\n     */\n    public String getDetail(PlayerDetail playerDetail) {\n        return playerPropertyMap.getDetail(playerDetail);\n    }\n\n    public int getId() {\n        return this.id;\n    }\n\n    public League getLeagueType() {\n        return this.leagueType;\n    }\n\n    public String getPlayerName() {\n        return playerPropertyMap.getDetail(PlayerDetail.PLAYER);\n    }\n    public String getNation() {\n        return playerPropertyMap.getDetail(PlayerDetail.NATION);\n    }\n    public String getPosition() {\n        return playerPropertyMap.getDetail(PlayerDetail.POSITION);\n    }\n    public String getTeam() {\n        return playerPropertyMap.getDetail(PlayerDetail.TEAM);\n    }\n\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"PlayerEntry{\");\n\n        sb.append(\"ID=\");\n        sb.append(getId());\n        sb.append(\", \");\n\n        sb.append(\"League=\");\n        sb.append(getLeagueType().getName());\n        sb.append(\", \");\n\n        Iterator<PlayerProperty> propertyIterator = playerPropertyMap.propertySet().iterator();\n        while (propertyIterator.hasNext()) {\n            PlayerProperty p = propertyIterator.next();\n            sb.append(p.getName());\n            sb.append(\"=\");\n            sb.append(getProperty(p));\n\n            if(propertyIterator.hasNext()) {\n                sb.append(\", \");\n            }\n        }\n        sb.append(\"}\");\n        return sb.toString();\n    }\n}\n\n/* Comment generated by Gradeer\n==============\nSubQuery.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment.codeprovided;\n\nimport java.util.Arrays;\n\n/**\n * Class designed to create SubQuery objects which make up parts of an individual query.\n *\n * @version 1.1  09/02/2023\n *\n * @author Maria-Cruz Villa-Uriol (m.villa-uriol@sheffield.ac.uk)\n * @author Ben Clegg\n *\n * Copyright (c) University of Sheffield 2023\n */\npublic class SubQuery\n{\n\tpublic static final String[] VALID_OPERATORS = {\"<\", \"<=\", \"=\", \">=\", \">\", \"!=\"};\n\n\tfinal PlayerProperty playerProperty;\n\tfinal String operator;\n\tfinal double value;\n\n\t/**\n\t * Constructor for subquery.\n\t *\n\t * @param playerProperty the property involved in the query.\n\t * @param operator the operator involved in the query.\n\t * @param value the value involved in the query.\n\t */\n\tpublic SubQuery(PlayerProperty playerProperty, String operator, double value) {\n\t\tthis.playerProperty = playerProperty;\n\t\tthis.operator = operator;\n\t\tthis.value = value;\n\t}\n\n\tpublic PlayerProperty getPlayerProperty()\n\t{\n\t\treturn playerProperty;\n\t}\n\n\tpublic String getOperator() {\n\t\treturn operator;\n\t}\n\n\tpublic double getValue() {\n\t\treturn value;\n\t}\n\n\tpublic String toString() {\n\t\treturn this.getPlayerProperty() + \" \" +\n\t\t\t\tthis.getOperator() + \" \" +\n\t\t\t\tthis.getValue();\n\t}\n\n\t/**\n\t * Check if a PlayerEntry satisfies the SubQuery.\n\t *\n\t * @param playerEntry the PlayerEntry to check\n\t * @return true if the player entry matches the SubQuery; false otherwise\n\t */\n\tprotected boolean playerEntriesMatchesSubQuery(PlayerEntry playerEntry) {\n\t\tPlayerProperty playerProperty = getPlayerProperty();\n\t\tdouble propertyValue = getValue();\n\n\t\tswitch (getOperator()) {\n\n\t\t\tcase \">\":\n\t\t\t\tif (playerEntry.getProperty(playerProperty) > propertyValue)\n\t\t\t\t\treturn true;\n\t\t\t\tbreak;\n\t\t\tcase \">=\":\n\t\t\t\tif (playerEntry.getProperty(playerProperty) >= propertyValue)\n\t\t\t\t\treturn true;\n\t\t\t\tbreak;\n\t\t\tcase \"<\":\n\t\t\t\tif (playerEntry.getProperty(playerProperty) < propertyValue)\n\t\t\t\t\treturn true;\n\t\t\t\tbreak;\n\t\t\tcase \"<=\":\n\t\t\t\tif (playerEntry.getProperty(playerProperty) <= propertyValue)\n\t\t\t\t\treturn true;\n\t\t\t\tbreak;\n\t\t\tcase \"=\":\n\t\t\t\tif (playerEntry.getProperty(playerProperty) == propertyValue)\n\t\t\t\t\treturn true;\n\t\t\t\tbreak;\n\t\t\tcase \"!=\":\n\t\t\t\tif (playerEntry.getProperty(playerProperty) != propertyValue)\n\t\t\t\t\treturn true;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((operator == null) ? 0 : operator.hashCode());\n\t\tlong temp;\n\t\ttemp = Double.doubleToLongBits(value);\n\t\tresult = prime * result + (int) (temp ^ (temp >>> 32));\n\t\tresult = prime * result + ((playerProperty == null) ? 0 : playerProperty.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tSubQuery other = (SubQuery) obj;\n\t\tif (operator == null) {\n\t\t\tif (other.operator != null)\n\t\t\t\treturn false;\n\t\t} else if (!operator.equals(other.operator))\n\t\t\treturn false;\n\t\tif (Double.doubleToLongBits(value) != Double.doubleToLongBits(other.value))\n\t\t\treturn false;\n\t\treturn playerProperty == other.playerProperty;\n\t}\n\n\t/**\n\t * Check if a String is a valid operator.\n\t *\n\t * @param operatorToCheck the String to check\n\t * @return true if the String is a valid operator; false otherwise\n\t */\n\tpublic static boolean isValidOperator(String operatorToCheck) {\n\t\treturn Arrays.asList(VALID_OPERATORS).contains(operatorToCheck);\n\t}\n}\n\n/* Comment generated by Gradeer\n==============\nPlayerProperty.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment.codeprovided;\n\nimport java.util.NoSuchElementException;\n\n/**\n * Provides a helper enum with constants representing the performance properties of a player entry.\n *\n * @version 1.0  06/04/2023\n *\n * @author Maria-Cruz Villa-Uriol (m.villa-uriol@sheffield.ac.uk)\n *\n * Copyright (c) University of Sheffield 2023\n */\npublic enum PlayerProperty {\n    AGE (\"Player's age\"),\n    MATCHES (\"Matches played\"),\n    MINUTES (\"Minutes played\"),\n    YELLOWCARDS (\"Yellow cards per 90 minutes\"),\n    REDCARDS (\"Red cards per 90 minutes\"),\n    GOALS (\"Total number of goals scored\"),\n    PKGOALS (\"Penalty kick goals per 90 minutes\"),\n    PKATTEMPTS (\"Penalty kicks attempted per 90 minutes\"),\n    ASSISTS (\"Assists per 90 minutes\"),\n    OWNGOALS (\"Own goals per 90 minutes\"),\n    PASSATTEMPTED (\"Passes attempted per 90 minutes\"),\n    PASSCOMPLETED (\"Passes completed per 90 minutes\"),\n    AERIALSWON (\"Aerial challenges won per 90 minutes\"),\n    AERIALSLOST (\"Aerial challenges lost per 90 minutes\"),\n    AERIALSWONPERC (\"Percentage of aerial challenges won per 90 minutes\"),\n    TACKLES (\"Tackles made per 90 minutes\"),\n    TACKLESWON (\"Tackles that regained ball possession per 90 minutes\"),\n    CLEARANCES (\"Clearances made per 90 minutes\"),\n    FOULSCOMMITTED (\"Fouls committed per 90 minutes\"),\n    PKCONCEDED (\"Penalty kicks conceded per 90 minutes\"),\n    SHOTS (\"Shots total per 90 minutes\"),\n    SHOTSTARGET (\"Shots on target per 90 minutes\"),\n    FOULSDRAWN (\"Fouls drawn per 90 minutes\"),\n    CROSSES (\"Crosses made per 90 minutes\"),\n    PKWON (\"Penalty kicks won per 90 minutes\");\n\n    private final String propertyName;\n\n    PlayerProperty(String pName) { propertyName = pName; }\n\n    public String getName() { return this.propertyName; }\n\n    /**\n     * Convert a name String (e.g. \"Matches\") to the matching PlayerProperty\n     * @param name the String to convert\n     * @return the matching PlayerProperty\n     * @throws NoSuchElementException if the String does not match any PlayerProperty\n     */\n    public static PlayerProperty fromName(String name) throws NoSuchElementException {\n        String pName = name.toUpperCase();\n        PlayerProperty playerProperty = null;\n        try {\n            playerProperty = PlayerProperty.valueOf(pName);\n        } catch (IllegalArgumentException e) {\n            throw new NoSuchElementException(\"No such property (\" + name + \")!\");\n        }\n        return playerProperty;\n    }\n    /**\n     * Convert a property name String (e.g. \"Matches played\") to the matching PlayerProperty\n     * @param name the String to convert\n     * @return the matching PlayerProperty\n     * @throws NoSuchElementException if the String does not match any PlayerProperty\n     */\n    public static PlayerProperty fromPropertyName(String name) throws NoSuchElementException {\n        for (PlayerProperty p : PlayerProperty.values()) {\n            if (p.getName().equals(name))\n                return p;\n        }\n        throw new NoSuchElementException(\"No such property (\" + name + \")!\");\n    }\n}\n\n/* Comment generated by Gradeer\n==============\nCategory.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment.codeprovided;\n\nimport java.util.NoSuchElementException;\n\n/**\n * Provides a helper enum with constants representing which player properties map to each category.\n * These will be used by RadarChart.\n *\n * @version 1.0  06/04/2023\n *\n * @author Maria-Cruz Villa-Uriol (m.villa-uriol@sheffield.ac.uk)\n *\n * Copyright (c) University of Sheffield 2023\n */\npublic enum Category {\n    GENERAL(\"general\") {\n        @Override\n        public PlayerProperty[] getProperties() {\n            return new PlayerProperty[]{PlayerProperty.AGE, PlayerProperty.MATCHES,\n                    PlayerProperty.MINUTES, PlayerProperty.YELLOWCARDS,\n                    PlayerProperty.REDCARDS};\n        }\n    },\n    GOALS(\"goals\") {\n        @Override\n        public PlayerProperty[] getProperties() {\n            return new PlayerProperty[]{PlayerProperty.GOALS, PlayerProperty.PKGOALS,\n                    PlayerProperty.PKATTEMPTS, PlayerProperty.ASSISTS,\n                    PlayerProperty.OWNGOALS};\n        }\n    },\n    PLAY(\"play\") {\n        @Override\n        public PlayerProperty[] getProperties() {\n            return new PlayerProperty[]{PlayerProperty.PASSATTEMPTED, PlayerProperty.PASSCOMPLETED,\n                    PlayerProperty.AERIALSWON, PlayerProperty.AERIALSLOST,\n                    PlayerProperty.AERIALSWONPERC};\n        }\n    },\n    DEFENCE(\"defence\") {\n        @Override\n        public PlayerProperty[] getProperties() {\n            return new PlayerProperty[]{PlayerProperty.TACKLES, PlayerProperty.TACKLESWON,\n                    PlayerProperty.CLEARANCES, PlayerProperty.FOULSCOMMITTED,\n                    PlayerProperty.PKCONCEDED};\n        }\n    },\n    ATTACK(\"attack\") {\n        @Override\n        public PlayerProperty[] getProperties() {\n            return new PlayerProperty[]{PlayerProperty.SHOTS, PlayerProperty.SHOTSTARGET,\n                    PlayerProperty.FOULSDRAWN, PlayerProperty.CROSSES,\n                    PlayerProperty.PKWON};\n        }\n    };\n\n    private final String categoryName;\n\n    Category(String catName) { categoryName = catName; }\n\n    public String getName()\n    {\n        return categoryName;\n    }\n    public abstract PlayerProperty[] getProperties();\n\n    /**\n     * Convert an identifier String (e.g. \"general\") to the matching Category.\n     *\n     * @param name the identifier to convert\n     * @return the matching Category\n     * @throws NoSuchElementException if the String does not match any Category\n     */\n    public static Category getCategoryFromName(String name) throws NoSuchElementException\n    {\n        for (Category cat : values()) {\n            if (cat.getName().equals(name))\n                return cat;\n        }\n        throw new NoSuchElementException(\"No such category (\" + name + \")!\");\n    }\n\n}\n\n/* Comment generated by Gradeer\n==============\nPlayerDetail.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment.codeprovided;\n\nimport java.util.NoSuchElementException;\n\n/**\n * Provides a helper enum with constants representing the details of a player entry.\n *\n * @version 1.0  06/04/2023\n *\n * @author Maria-Cruz Villa-Uriol (m.villa-uriol@sheffield.ac.uk)\n *\n * Copyright (c) University of Sheffield 2023\n */\npublic enum PlayerDetail {\n    PLAYER (\"Player's name\"),\n    NATION (\"Player's nation\"),\n    POSITION (\"Position in the pitch\"),\n    TEAM (\"Team\u2019s name\");\n\n    private final String detailName;\n\n    PlayerDetail(String pName) { detailName = pName; }\n\n    public String getName() { return this.detailName; }\n\n    /**\n     * Convert a name String (e.g. \"Nation\") to the matching PlayerProperty.\n     *\n     * @param name the String to convert\n     * @return the matching PlayerDetail\n     * @throws NoSuchElementException if the String does not match any PlayerDetail\n     */\n    public static PlayerDetail fromName(String name) throws NoSuchElementException {\n        String pName = name.toUpperCase();\n        PlayerDetail playerDetail = null;\n        try {\n            playerDetail = PlayerDetail.valueOf(pName);\n        } catch (IllegalArgumentException e) {\n            throw new NoSuchElementException(\"No such detail (\" + name + \")!\");\n        }\n        return playerDetail;\n    }\n}\n\n/* Comment generated by Gradeer\n==============\nLeague.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment.codeprovided;\n\n/**\n * Provides a helper enum with constants representing the accepted leagues.\n *\n * @version 1.0  06/04/2023\n *\n * @author Maria-Cruz Villa-Uriol (m.villa-uriol@sheffield.ac.uk)\n *\n * Copyright (c) University of Sheffield 2023\n */\npublic enum League {\n    ALL(\"All leagues\"),\n    EPL(\"English Premier League\"),\n    LIGA(\"La Liga\");\n\n    private final String leagueTypeName;\n\n    League(String lTName) { leagueTypeName = lTName; }\n\n    public String getName()\n    {\n        return leagueTypeName;\n    }\n\n    public static League fromName(String leagueName)\n    {\n        for (League l : League.values()) {\n            if (l.getName().equals(leagueName))\n                return l;\n        }\n        return null;\n    }\n}\n\n/* Comment generated by Gradeer\n==============\nQuery.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment.codeprovided;\n\nimport java.util.*;\n\n/**\n * Class designed to be used to create Query objects from the Query List.\n *\n * @version 1.1  09/02/2023\n *\n * @author Maria-Cruz Villa-Uriol (m.villa-uriol@sheffield.ac.uk)\n * @author Ben Clegg\n *\n * Copyright (c) University of Sheffield 2023\n */\npublic class Query {\n\n    final List<SubQuery> subQueryList;\n    final League leagueType;\n\n    /**\n     * Constructor.\n     *\n     * @param subQueryList\n     * @param leagueType\n     */\n    public Query(List<SubQuery> subQueryList, League leagueType) {\n        this.subQueryList = subQueryList;\n        this.leagueType = leagueType;\n    }\n\n    /**\n     * Get the league type.\n     *\n     * @return league type.\n     */\n    public League getLeagueType() {\n        return leagueType;\n    }\n\n    /**\n     * Get SubQueries of this Query.\n     *\n     * @return subQueryList\n     */\n    public List<SubQuery> getSubQueryList() {\n        return subQueryList;\n    }\n\n\n    /**\n     * Apply the Query to the players of a PlayerCatalog, retrieve the players which match.\n     *\n     * @param playerCatalog the PlayerCatalog to query\n     * @return List of filtered player entries\n     */\n    public List<PlayerEntry> executeQuery(AbstractPlayerCatalog playerCatalog) {\n        // Start by adding all the player entries with the matching type\n        List<PlayerEntry> filteredPlayerEntriesList =\n                new ArrayList<>(playerCatalog.getPlayerEntriesList(leagueType));\n\n        // Continuously filter the player entries according to each SubQuery\n        for (SubQuery subQuery : subQueryList) {\n            filteredPlayerEntriesList =\n                    executeSubQuery(filteredPlayerEntriesList, subQuery);\n\n        }\n        // Return the filtered player entries\n        return filteredPlayerEntriesList;\n    }\n\n    /**\n     * Filter provided player entries according to a SubQuery.\n     *\n     * @param playerEntries the Collection of relevant player entries\n     * @param subQuery the SubQuery to use to filter player entries\n     * @return List of all player entries which meet criteria\n     */\n    private List<PlayerEntry> executeSubQuery(Collection<PlayerEntry> playerEntries, SubQuery subQuery) {\n        List<PlayerEntry> filteredPlayerEntriesList = new ArrayList<>();\n\n        for (PlayerEntry w : playerEntries) {\n            if(subQuery.playerEntriesMatchesSubQuery(w))\n                filteredPlayerEntriesList.add(w);\n        }\n        return filteredPlayerEntriesList;\n    }\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((subQueryList == null) ? 0 : subQueryList.hashCode());\n\t\tresult = prime * result + ((leagueType == null) ? 0 : leagueType.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tQuery other = (Query) obj;\n\t\tif (subQueryList == null) {\n\t\t\tif (other.subQueryList != null)\n\t\t\t\treturn false;\n\t\t} else if (!subQueryList.equals(other.subQueryList))\n\t\t\treturn false;\n        return leagueType == other.leagueType;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Query: \").append(leagueType).append(\"{\");\n        Iterator<SubQuery> subQueryIterator = subQueryList.iterator();\n        while (subQueryIterator.hasNext()) {\n            sb.append(subQueryIterator.next());\n            if(subQueryIterator.hasNext())\n                sb.append(\", \");\n        }\n        sb.append(\"}\");\n        return sb.toString();\n    }\n}\n\n/* Comment generated by Gradeer\n==============\nAbstractRadarChartPanel.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment.codeprovided.gui;\n\nimport javax.swing.*;\n\n/**\n * Abstract class for displaying a Histogram.\n * Please pay attention to the note comment below the constructor.\n * This should display the axes and bars of the histogram, and a vertical line to show the average measurement.\n * Should be updated when the histogram is updated\n *\n * Should be implemented as uk.ac.sheffield.assignment2021.gui.HistogramPanel\n *\n * @version 1.0 02/03/2021\n *\n * @author Ben Clegg\n *\n * Copyright (c) University of Sheffield 2021\n */\npublic class AbstractRadarChartPanel extends JPanel {\n\n    @SuppressWarnings({\"FieldCanBeLocal\", \"unused\"})\n    private final AbstractPlayerDashboardPanel parentPanel;\n    private final AbstractRadarChart radarChart;\n\n    public AbstractRadarChartPanel(AbstractPlayerDashboardPanel parentPanel, AbstractRadarChart radarChart) {\n        super();\n        this.parentPanel = parentPanel;\n        this.radarChart = radarChart;\n    }\n\n    /* NOTE: your RadarChartPanel must override JPanel's `protected void paintComponent(Graphics g)`,\n    in order to redraw your Radar Chart whenever it is updated.\n    For example:\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Dimension d = getSize();\n        Graphics2D g2 = (Graphics2D) g;\n\n        Line2D l = new Line2D.Double(\n            0,\n            0,\n            d.width,\n            d.height\n        );\n        g2.draw(l);\n    }\n\n     */\n\n    public AbstractRadarChart getRadarChart()\n    {\n        return radarChart;\n    }\n\n    public AbstractPlayerDashboardPanel getParentPanel()\n    {\n        return parentPanel;\n    }\n}\n\n\n/* Comment generated by Gradeer\n==============\nPlayerEntryDashboard.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment.codeprovided.gui;\n\nimport javax.swing.*;\n\n/**\n * Creates the GUI\n *\n * @version 1.1  09/02/2021\n *\n * @author Maria-Cruz Villa-Uriol (m.villa-uriol@sheffield.ac.uk)\n *\n * Copyright (c) University of Sheffield 2021\n */\npublic class PlayerEntryDashboard extends JFrame {\n\n\tpublic PlayerEntryDashboard(AbstractPlayerDashboardPanel panel) {\n\t\tsetTitle(\"Footie Dashboard\");\n\t\tadd(panel);\n\t\t// maximises the JFrame\n\t\tsetExtendedState(MAXIMIZED_BOTH);\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tsetVisible(true);\n\t}\n}\n\n/* Comment generated by Gradeer\n==============\nAbstractPlayerDashboardPanel.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment.codeprovided.gui;\n// import statements\n\nimport uk.ac.sheffield.com1003.assignment.codeprovided.*;\nimport uk.ac.sheffield.com1003.assignment.gui.RadarChart;\nimport uk.ac.sheffield.com1003.assignment.gui.RadarChartPanel;\n\nimport javax.swing.*;\nimport javax.swing.border.Border;\nimport javax.swing.border.TitledBorder;\n\nimport java.awt.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Vector;\nimport java.util.stream.Collectors;\n\n/**\n * Class that provides a basic implementation of the main elements in the GUI as discussed in the handout.\n * Please consider the methods that need to be implemented by overriding, including the method described in the\n * note at the end of this class.\n *\n * Should be implemented as uk.ac.sheffield.assignment2021.gui.PlayerDashboardPanel\n *\n * @version 1.1 09/02/2021\n *\n * @author Maria-Cruz Villa-Uriol (m.villa-uriol@sheffield.ac.uk)\n * @author Ben Clegg\n *\n * Copyright (c) University of Sheffield 2021\n */\n\n// constructor\n@SuppressWarnings(\"ALL\")\npublic abstract class AbstractPlayerDashboardPanel extends JPanel {\n\n    // instance variables\n\n    // playerCatalog provides a convenient access to the original datasets - might be of use\n    protected final AbstractPlayerCatalog playerCatalog;\n    // filteredPlayerEntriesList is the list that needs to be kept up to date with the results of\n    // running the list of SubQuery objects in queryConditionList\n    protected List<PlayerEntry> filteredPlayerEntriesList;\n\n    // TODO, update explanation\n    // subQueryList contains all the conditions as they are added when the button buttonAddFilter is clicked\n    // the contents of subQueryList will need to be cleared if the buttonClearFilters is clicked\n    protected List<SubQuery> subQueryList = new ArrayList<>();\n\n    // by default all player entries for both leagues are used\n    protected League selectedLeagueType = League.ALL;\n\n    // these need to be set up to nothing\n    protected String selectedPlayerName = \"\";\n    protected String selectedPlayerNation = \"\";\n    protected String selectedPlayerPosition = \"\";\n    protected String selectedTeam = \"\";\n\n    // radar chart being shown\n    protected AbstractRadarChart radarChart;\n\n\n    // starting the definition of buttons\n    // buttonAddFilter will add a new query condition to queryConditionList when clicked\n    // clicking this button implies calling the method addFilter(...)\n    protected final JButton buttonAddFilter = new JButton(\"Add Filter\");\n    // buttonClearFilters will remove all query conditions in queryConditionList when clicked\n    // clicking this button implies calling the method clearFilters(...)\n    protected final JButton buttonClearFilters = new JButton(\"Clear All Filters\");\n\n    // defining the combobox used to select the league type to which the filters (queryConditionList or list of SubQuery object) need to be applied\n    protected String[] leagueTypes = { League.ALL.getName(), League.EPL.getName(), League.LIGA.getName() };\n    protected JComboBox<String> comboLeagueTypes = new JComboBox<>(leagueTypes);\n\n    // defining the comboboxes used to select player names, nation, player's position and team\n    // this subselection will be used by the filters (queryConditionList or list of SubQuery object)\n    // when they need to be applied\n    protected ArrayList<String> playerNamesList = new ArrayList<>();\n    protected JComboBox<String> comboPlayerNames = new JComboBox<>();\n\n    protected ArrayList<String> nationList = new ArrayList<>();\n    protected JComboBox<String> comboNations = new JComboBox<>();\n\n    protected ArrayList<String> positionList = new ArrayList<>();\n    protected JComboBox<String> comboPositions = new JComboBox<>();\n\n    protected ArrayList<String> teamList = new ArrayList<>();\n    protected JComboBox<String> comboTeams = new JComboBox<>();\n\n    Vector<String> propertyValues = new Vector<>(Arrays.stream(PlayerProperty.values())\n            .map(PlayerProperty::getName).collect(Collectors.toList()));\n\n    Vector<String> categoryValues = new Vector<>(Arrays.stream(Category.values())\n            .map(Category::getName).collect(Collectors.toList()));\n\n    protected JComboBox<String> comboQueryProperties = new JComboBox<>(propertyValues);\n\n    // defining the combobox used to select the operator that will be used to build the filter (or SubQuery object) than will be applied\n    protected String[] operators = {\">\", \">=\", \"<\", \"<=\", \"=\", \"!=\"};\n    protected JComboBox<String> comboOperators = new JComboBox<>(operators);\n\n    // defining the textfield where the value of the SubQuery (or filter)\n    protected JTextField value = new JTextField(5);\n\n    // defining all the labels to facilitate the what goes where in the GUI\n    protected JLabel leagueTypeSelectorLabel = new JLabel(\"League:\", SwingConstants.LEFT);\n    protected JLabel playerSelectorLabel = new JLabel(\"Player's name:\", SwingConstants.LEFT);\n    protected JLabel nationSelectorLabel = new JLabel(\"Nation:\", SwingConstants.LEFT);\n    protected JLabel positionSelectorLabel = new JLabel(\"Position:\", SwingConstants.LEFT);\n    protected JLabel teamSelectorLabel = new JLabel(\"Team:\", SwingConstants.LEFT);\n\n    protected JLabel subQueryLabel = new JLabel(\"Filter by property:\", SwingConstants.LEFT);\n    protected JLabel operatorLabel = new JLabel(\"Operator:\", SwingConstants.LEFT);\n    protected JLabel operatorValueLabel = new JLabel(\"Value:\", SwingConstants.LEFT);\n    protected JLabel subQueryListLabel = new JLabel(\"List of filters (or subqueries):\", SwingConstants.LEFT);\n    protected JLabel radarChartCategoryLabel = new JLabel(\"Radar chart category:\", SwingConstants.LEFT);\n\n    // defining all the checkboxes to control what is shown in radar plot\n    protected JCheckBox minCheckBox = new JCheckBox(\"Minimum\");\n    protected JCheckBox maxCheckBox = new JCheckBox(\"Maximum\");\n    protected JCheckBox averageCheckBox = new JCheckBox(\"Average\");\n\n\n    // defining the three JTextAreas that will need to be updated every time the buttons\n    // buttonAddFilter and buttonClearFilters are clicked\n    // subQueriesTextArea will show the contents of subQueryList\n    protected JTextArea subQueriesTextArea = new JTextArea(1, 50);\n    // statisticsTextArea will show basic summary statistics for the filteredPlayerEntriesList\n    // (which contains the results after executing the filters or SubQuery in subQueryList)\n    protected JTextArea statisticsTextArea = new JTextArea(5, 70);\n    // filteredPlayerEntriesTextArea will show the results contained in the filteredPlayerEntriesTextArea object\n    protected JTextArea filteredPlayerEntriesTextArea = new JTextArea(30, 70);\n\n    // defining the gui elements that will show the radar chart\n    protected JComboBox<String> comboRadarChartCategories = new JComboBox<>(categoryValues);\n\n    // titles for TitleBorders used to name the three main GUI areas\n    protected String statisticsTitle = \"PLAYER CATALOG STATISTICS\";\n    protected String playerEntriesTitle = \"PLAYER ENTRIES\";\n    protected String radarChartTitle = \"RADAR CHART\";\n\n\n    // Constructor\n    public AbstractPlayerDashboardPanel(AbstractPlayerCatalog playerCatalog) {\n        Border blackline = BorderFactory.createLineBorder(Color.black);\n\n        // providing access to the playerCatalog so that this class can access its contents if required\n        this.playerCatalog = playerCatalog;\n        // by default the GUI starts showing all player entries for both leagues\n        this.filteredPlayerEntriesList = playerCatalog.getPlayerEntriesList(League.ALL);\n\n        subQueriesTextArea.setName(\"subQueries\");\n        comboQueryProperties.setName(\"playerProperties\");\n        value.setName(\"filterValue\");\n        filteredPlayerEntriesTextArea.setName(\"filteredPlayerEntries\");\n        statisticsTextArea.setName(\"playerCatalogStats\");\n        comboOperators.setName(\"operators\");\n        comboLeagueTypes.setName(\"leagueTypes\");\n        buttonAddFilter.setName(\"addFilter\");\n        buttonClearFilters.setName(\"clearFilters\");\n\n        // building the GUI using a combination of JPanels and a range of LayoutManagers\n        // to get a structured GUI\n        this.setLayout(new BorderLayout());\n\n        // Query panel\n        JPanel queryPanel = new JPanel();\n        queryPanel.setLayout(new GridLayout(4, 1));\n\n        JPanel typeSelectorPanel = new JPanel();\n        typeSelectorPanel.setLayout(new FlowLayout());\n        typeSelectorPanel.add(leagueTypeSelectorLabel);\n        typeSelectorPanel.add(comboLeagueTypes);\n\n        typeSelectorPanel.add(playerSelectorLabel);\n        typeSelectorPanel.add(comboPlayerNames);\n        typeSelectorPanel.add(nationSelectorLabel);\n        typeSelectorPanel.add(comboNations);\n        typeSelectorPanel.add(positionSelectorLabel);\n        typeSelectorPanel.add(comboPositions);\n        typeSelectorPanel.add(teamSelectorLabel);\n        typeSelectorPanel.add(comboTeams);\n\n        JPanel filterBuilderPanel = new JPanel();\n        filterBuilderPanel.setLayout(new FlowLayout());\n        filterBuilderPanel.add(subQueryLabel);\n        filterBuilderPanel.add(comboQueryProperties);\n        filterBuilderPanel.add(operatorLabel);\n        filterBuilderPanel.add(comboOperators);\n        filterBuilderPanel.add(operatorValueLabel);\n        filterBuilderPanel.add(value);\n        filterBuilderPanel.add(buttonAddFilter);\n        filterBuilderPanel.add(buttonClearFilters);\n\n        queryPanel.add(typeSelectorPanel);\n        queryPanel.add(filterBuilderPanel);\n        queryPanel.add(subQueryListLabel);\n\n        JScrollPane jscQueries = new JScrollPane(subQueriesTextArea);\n        queryPanel.add(jscQueries);\n        queryPanel.setBorder(blackline);\n\n        // Radar chart panel\n        JPanel radarChartContainer = new JPanel();\n        JPanel controlRadarChartContainer = new JPanel();\n\n        radarChartContainer.setLayout(new BorderLayout());\n        controlRadarChartContainer.add(radarChartCategoryLabel);\n        controlRadarChartContainer.add(comboRadarChartCategories);\n        controlRadarChartContainer.add(minCheckBox);\n        controlRadarChartContainer.add(maxCheckBox);\n        controlRadarChartContainer.add(averageCheckBox);\n\n        String categoryName = (String) comboRadarChartCategories.getSelectedItem();\n        Category cat = Category.getCategoryFromName(categoryName);\n        List<PlayerProperty> listProperties = Arrays.asList(cat.getProperties());\n        radarChart = new RadarChart(playerCatalog, filteredPlayerEntriesList, listProperties);\n        AbstractRadarChartPanel radarChartPanel = new RadarChartPanel(this, radarChart);\n        radarChartContainer.add(radarChartPanel, BorderLayout.CENTER);\n        radarChartContainer.add(controlRadarChartContainer, BorderLayout.SOUTH);\n\n        TitledBorder tbRadarChart = BorderFactory.createTitledBorder(\n                blackline, radarChartTitle);\n        tbRadarChart.setTitleJustification(TitledBorder.CENTER);\n        radarChartContainer.setBorder(tbRadarChart);\n\n\n        // Statistics panel\n        JPanel statisticsPanel = new JPanel();\n        statisticsPanel.setLayout(new BorderLayout());\n        JScrollPane statisticsScrollPane = new JScrollPane(statisticsTextArea,\n                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n        statisticsPanel.add(statisticsScrollPane, BorderLayout.CENTER);\n        statisticsPanel.setBorder(BorderFactory.createLineBorder(Color.black));\n        TitledBorder tbStatistics = BorderFactory.createTitledBorder(\n                blackline, statisticsTitle);\n        tbStatistics.setTitleJustification(TitledBorder.CENTER);\n        statisticsPanel.setBorder(tbStatistics);\n\n        // Filtered player entries panel\n        JPanel playerEntriesPanel = new JPanel();\n        playerEntriesPanel.setLayout(new BorderLayout());\n        JScrollPane playerEntriesScrollPane = new JScrollPane(filteredPlayerEntriesTextArea,\n                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n        playerEntriesPanel.add(playerEntriesScrollPane, BorderLayout.CENTER);\n        playerEntriesPanel.setBorder(BorderFactory.createLineBorder(Color.black));\n        TitledBorder tbPlayerEntries = BorderFactory.createTitledBorder(\n                blackline, playerEntriesTitle);\n        tbPlayerEntries.setTitleJustification(TitledBorder.CENTER);\n        playerEntriesPanel.setBorder(tbPlayerEntries);\n\n        JPanel playerCatalogPanel = new JPanel();\n        playerCatalogPanel.setLayout(new BorderLayout());\n        playerCatalogPanel.add(statisticsPanel, BorderLayout.NORTH);\n        playerCatalogPanel.add(playerEntriesPanel, BorderLayout.SOUTH);\n\n        this.add(queryPanel, BorderLayout.NORTH);\n        this.add(radarChartContainer, BorderLayout.CENTER);\n        this.add(playerCatalogPanel, BorderLayout.EAST);\n\n        // dynamically populate the comboboxes with Player details\n        this.populatePlayerDetailsComboBoxes();\n\n        // adding the listeners, you will need to implement this method to register the events generated\n        // by the GUI components that will be expecting a change in the results being displayed by the GUI\n        this.addListeners();\n    }\n\n    /**\n     * Updates the radar chart with the currently filtered player entries and selected category\n     */\n    public abstract void updateRadarChart();\n\n\n    /**\n     * @return the active SubQueries\n     */\n    public List<SubQuery> getAllSubQueries() {\n        return subQueryList;\n    }\n\n    /**\n     * getFilteredPlayerEntriesList method - getter of filtered player entries list\n     * @return List of PlayerEntry objects after running filtering SubQueries\n     */\n    public List<PlayerEntry> getFilteredPlayerEntriesList() {\n        return filteredPlayerEntriesList;\n    }\n\n    // list of abstract methods starts\n\n    /**\n     * populatePlayerDetailsComboBoxes method - dynamically populates the player detail comboboxes:\n     * comboPlayerNames, comboNations, comboPositions, and comboTeams.\n     */\n    public abstract void populatePlayerDetailsComboBoxes();\n\n    /**\n     * addListeners method - adds relevant actionListeners to the GUI components\n     * You will need to listen (at least) to the following:\n     * - buttonAddFilter\n     * - buttonClearFilters\n     * - comboLeagueTypes, comboPlayerNames, comboNations, comboPositions, and comboTeams,\n     *              if you want the filteredPlayerEntriesTextArea to be updated\n     *              to show only the player entries specified by these comboboxes\n     * - comboRadarChartCategories, to update the properties that the radar chart should display\n     */\n    public abstract void addListeners();\n\n    /**\n     * addFilter method -\n     * 1- this method is called when the JButton buttonAddFilter is clicked\n     * 2- adds a new filter (a SubQuery object) to subQueryList ArrayList\n     * 3- updates the GUI results accordingly, i.e. updates the three JTextAreas as follows:\n     *    3a- subQueriesTextArea will show the new SubQuery\n     *    3b- statisticsTextArea will show the updated statistics for the results after applying this filter\n     *    3c- filteredPlayerEntriesTextArea will show the contents of filteredPlayerEntriesList (the results after applying this filter)\n     *    3d- the radar chart is updated to display the newly filtered player entries (Note: this can alternatively be done\n     *    in another method)\n     */\n    public abstract void addFilter();\n\n    /**\n     * clearFilters method - clears all filters from the subQueryList ArrayList and updates\n     * the relevant GUI components when the button buttonClearFilters is clicked\n     */\n    public abstract void clearFilters();\n\n    /**\n     * updateStatistics method - updates the statistics to be displayed in the\n     * statisticsTextArea when the results being shown in the GUI need to be updated,\n     * recalculates the average, minimum and maximum values for each player property.\n     */\n    public abstract void updateStatistics();\n\n    /**\n     * updatePlayerCatalogDetailsBox method - updates the player details panel when changes are made\n     */\n    public abstract void updatePlayerCatalogDetailsBox();\n\n    /**\n     * executeQuery method - executes the complete query to the relevant player list\n     */\n    public abstract void executeQuery();\n\n    /**\n     * isMinCheckBoxSelected method - executes the complete query to the relevant player list\n     */\n    public abstract boolean isMinCheckBoxSelected();\n\n    /**\n     * isMaxCheckBoxSelected method - executes the complete query to the relevant player list\n     */\n    public abstract boolean isMaxCheckBoxSelected();\n\n    /**\n     * isAverageCheckBoxSelected method - checks if average\n     */\n    public abstract boolean isAverageCheckBoxSelected();\n\n\n    /*\n     * NOTE: You will also need to override JPanel's paintComponent(Graphics g) method, to redraw the GUI\n     * Remember that to redraw your panel, you should never call the paintComponent(Graphics g) explicitly,\n     * you will be calling instead the repaint() method! (Check lab sheet of week 7).\n     * The repaint() method will make sure that the appropriate paintComponent is called.\n     */\n\n}\n\n\n/* Comment generated by Gradeer\n==============\nAbstractRadarChart.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment.codeprovided.gui;\n\nimport uk.ac.sheffield.com1003.assignment.codeprovided.AbstractPlayerCatalog;\nimport uk.ac.sheffield.com1003.assignment.codeprovided.PlayerEntry;\nimport uk.ac.sheffield.com1003.assignment.codeprovided.PlayerProperty;\n\nimport java.util.*;\n\n/**\n * Abstract class providing some functionality to store and access a histogram\n * Histograms split a set of values (e.g. property measurements) into a number of \"bins\", between the minimum\n * and maximum values of the set of values. Each value is added to the bin that it matches to.\n * These bins can then be plotted as bars; see AbstractHistogramPanel\n *\n * Should be implemented as uk.ac.sheffield.assignment2021.gui.Histogram\n *\n * @version 1.0 02/03/2021\n *\n * @author Ben Clegg\n *\n * Copyright (c) University of Sheffield 2021\n */\npublic abstract class AbstractRadarChart {\n\n    protected Map<PlayerProperty, RadarAxisValues> radarAxesValues;\n\n    protected final AbstractPlayerCatalog playerCatalog;\n    protected List<PlayerEntry> filteredPlayerEntries;\n    protected List<PlayerProperty> playerRadarChartProperties;\n\n    /**\n     * Constructor. Called by AbstractPlayerDashboardPanel\n     * @param playerCatalog to allow for getting min / max / avg values\n     * @param filteredPlayerEntriesList a List of player entries to generate\n     *                                  a radar chart for the selected categories, which have\n     *                                  already been filtered by the GUI's queries.\n     * @param radarChartPlayerProperties the PlayerProperty to generate a radar chart for.\n     */\n    public AbstractRadarChart(AbstractPlayerCatalog playerCatalog,\n                              List<PlayerEntry> filteredPlayerEntriesList,\n                              List<PlayerProperty> radarChartPlayerProperties) {\n        this.playerCatalog = playerCatalog;\n        this.filteredPlayerEntries = filteredPlayerEntriesList;\n        this.playerRadarChartProperties = radarChartPlayerProperties;\n        this.radarAxesValues = new HashMap<>();\n        updateRadarChartContents(radarChartPlayerProperties, filteredPlayerEntriesList);\n    }\n\n    /**\n     * This method should completely update (i.e. reset) the radar chart,\n     * based on a newly selected category and player entries.\n     * Since these values may have changed completely, it is recommended that you generate an entirely new\n     * set of RadarAxisValues with the appropriate values according to the properties in each category.\n     * PlayerPropertyMap may give you some hints on how to use the Map interface.\n     * @param radarChartPlayerProperties the list of PlayerProperty that the radar chart should plot\n     * @param filteredPlayerEntriesList the PlayerEntry that have currently been filtered by the GUI\n     */\n    public abstract void updateRadarChartContents(List<PlayerProperty> radarChartPlayerProperties,\n                                                  List<PlayerEntry> filteredPlayerEntriesList);\n\n    /**\n     * @return the list of player entry properties displayed by the radar chart\n     */\n    public abstract List<PlayerProperty> getPlayerRadarChartProperties() throws NoSuchElementException;\n\n    /**\n     * @return the map of player entry properties to RadarAxisValues displayed by this radar chart\n     */\n    public abstract Map<PlayerProperty, RadarAxisValues> getRadarPlotAxesValues() throws NoSuchElementException;\n\n    /**\n     * @return the player catalog displayed by this radar chart\n     */\n    public abstract AbstractPlayerCatalog getPlayerCatalog();\n\n    /**\n     * @return the filteres list of player entries\n     */\n    public abstract List<PlayerEntry> getFilteredPlayerEntries();\n\n}\n\n/* Comment generated by Gradeer\n==============\nRadarAxisValues.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment.codeprovided.gui;\n\n/**\n * A bin of a histogram.\n * See AbstractHistogram for more details.\n *\n * @version 1.0 02/03/2021\n *\n * @author Ben Clegg\n *\n * Copyright (c) University of Sheffield 2021\n */\n\npublic class RadarAxisValues\n{\n    private final double min;\n    private final double max;\n    private final double average;\n\n    public RadarAxisValues(double min, double max, double average)\n    {\n        this.min = min;\n        this.max = max;\n        this.average = average;\n    }\n\n    public double getMin()\n    {\n        return min;\n    }\n\n    public double getMax()\n    {\n        return max;\n    }\n\n    public double getAverage()\n    {\n        return average;\n    }\n\n}\n\n\n/* Comment generated by Gradeer\n==============\nPlayerPropertyMap.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment.codeprovided;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * A simplified Map wrapper to be used by a PlayerEntry, storing the values for each of its properties.\n * This wrapper stores a HashMap rather than extending it to de-expose unneeded methods.\n * Copyright (c) University of Sheffield 2023\n *\n * @version 1.0 10/02/2023\n *\n * @author Ben Clegg\n */\npublic class PlayerPropertyMap {\n\n    // Consult the Javadocs for Map & HashMap for more information\n    private final Map<PlayerProperty, Double> propertyToValuesMap = new HashMap<>();\n\n    // Consult the Javadocs for Map & HashMap for more information\n    private final Map<PlayerDetail, String> detailsMap = new HashMap<>();\n\n\n    /**\n     * Add a PlayerProperty and value pair. See HashMap.put() for more technical details.\n     * @param playerProperty the property to store\n     * @param value the value associated with the property\n     */\n    public void put(PlayerProperty playerProperty, double value) {\n        propertyToValuesMap.put(playerProperty, value);\n    }\n\n    /**\n     * Add a PlayerDetail and value pair. See HashMap.put() for more technical details.\n     * @param playerDetail the detail to store\n     * @param detail the value associated with the property\n     */\n    public void putDetail(PlayerDetail playerDetail, String detail) {\n        detailsMap.put(playerDetail, detail);\n    }\n\n\n    /**\n     * Retrieve a value associated with a given PlayerProperty. See HashMap.get() for more technical details.\n     * @param playerProperty the PlayerProperty to retrieve the value of\n     * @return the retrieved value\n     */\n    public double get(PlayerProperty playerProperty) {\n        return propertyToValuesMap.get(playerProperty);\n    }\n\n    /**\n     * Retrieve a detail associated with a given PlayerDetail. See HashMap.get() for more technical details.\n     * @param playerDetail the PlayerDetail to retrieve the value of\n     * @return the retrieved value\n     */\n    public String getDetail(PlayerDetail playerDetail) {\n        return detailsMap.get(playerDetail);\n    }\n\n    /**\n     * Get the properties stored in the map. See HashMap.keySet() for more technical details.\n     * @return the properties stored in the map\n     */\n    public Set<PlayerProperty> propertySet() {\n        return propertyToValuesMap.keySet();\n    }\n\n}\n\n/* Comment generated by Gradeer\n==============\nAbstractPlayerCatalog.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment.codeprovided;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * Abstract class designed to be extended. \n * Provides basic reading functionalities of datasets with player entries and queries.\n *\n * @version 1.1 09/02/2023\n *\n * @author Maria-Cruz Villa-Uriol (m.villa-uriol@sheffield.ac.uk)\n * @author Ben Clegg\n *\n * Copyright (c) University of Sheffield 2023\n */\npublic abstract class AbstractPlayerCatalog {\n\n\tprotected final Map<League, List<PlayerEntry>> playerEntriesMap;\n\n\t/**\n\t * Constructor - reads datasets with player catalogue (player entries\n\t * and initialises the playerEntriesMap Map\n     */\n    public AbstractPlayerCatalog(String eplFilename, String ligaFilename) {\n\n        playerEntriesMap = new HashMap<>();\n        // editPlayerCatalog will read the data and will insert the list of player entries\n        // into the playerEntriesMap variable\n        editPlayerCatalog(League.EPL, eplFilename);\n        editPlayerCatalog(League.LIGA, ligaFilename);\n\n        // updatePlayerCatalog will update playerEntriesMap to contain 'also'\n        // an additional list containing all player entries\n        // (in this case Premier League and La Liga)\n        updatePlayerCatalog();\n    }\n\n    public int getNumberPlayerEntries(League league)\n    {\n        return playerEntriesMap.get(league).size();\n    }\n\n    /**\n     * Reads the two CSV files and the type passed by main. It then reads the contents of the files\n     * and creates the relevant PlayerEntry objects and returns them into a list. Catches exception errors\n     * should they occur.\n     *\n     * @param dataFile This will be the dataset providing data about the league\n     * @param league This is a League enum containing the league type\n     * @return List of PlayerEntry objects\n     */\n    public List<PlayerEntry> readDataFile(String dataFile, League league) throws IllegalArgumentException {\n        List<PlayerEntry> playerEntriesList = new ArrayList<>();\n        int count = 1;\n        dataFile = dataFile.replaceAll(\" \", \"\");\n\n        try (BufferedReader br = new BufferedReader(new FileReader(dataFile))) {\n            String line = br.readLine();\n            if (line == null) {\n                throw new IllegalArgumentException(\"File is empty. Provide a valid dataset.\");\n            }\n            while ((line = br.readLine()) != null) {\n                try {\n                    // The player entry ID is created by this reader; it is not provided in the original files\n                    // The ID should _not_ be modified later\n                    int id = count;\t\t\n                    PlayerEntry playerEntry = new PlayerEntry(id, league, parsePlayerEntryLine(line));\n                    playerEntriesList.add(playerEntry);\n                    count++;\n\n                } catch (NumberFormatException e) {\n                    System.err.println(\"File format is incorrect; only double values are allowed.\");\n                } catch (IllegalArgumentException e) {\n                    System.err.println(\"Malformed player entry line: \" + line);\n                    e.printStackTrace();\n                }\n            }\n        } catch (FileNotFoundException e) {\n            System.err.println(dataFile + \" could not be found. Provide a correct filename.\" + e.getMessage());\n        } catch (IOException e) {\n            System.err.println(\"IO Exception: \" + e.getMessage());\n            e.printStackTrace();\n        }\n        return playerEntriesList;\n    }\n\n    /**\n     * Parse the properties from a given line from a player catalog file.\n     * You can expect that each value appears in the same order as the columns in the file,\n     * and that this order will not change.\n     *\n     * @param line the line to parse\n     * @return a PlayerPropertyMap constructed from the parsed row, containing values for every property\n     * @throws IllegalArgumentException if the line is malformed (i.e. does not include every property\n     * for a single player, or contains undefined properties)\n     */\n    public abstract PlayerPropertyMap parsePlayerEntryLine(String line) throws IllegalArgumentException;\n\n    /**\n     * Updates playerEntriesMap to contain 'also' an additional list\n     * containing ALL player entries (in this case Premier League and La Liga)\n     * Note: this should not modify the other player entry lists\n     */\n    public abstract void updatePlayerCatalog();\n\n    /**\n     * Read the contents of filename and stores it.\n     *\n     * @param league indicates which list of player entries to modify\n     * @param filename the name of the .csv to read\n     */\n    public void editPlayerCatalog(League league, String filename){\n        playerEntriesMap.put(league, new ArrayList<>(readDataFile(filename, league)));\n    }\n    \n    /**\n     * Returns the list of player entries relevant to the specified league.\n     *\n     * @param league the league type to retrieve\n     * @return List<PlayerEntry>, a list of Premier League, La Liga, or ALL Player entries\n     */\n    public List<PlayerEntry> getPlayerEntriesList(League league) {\n        return playerEntriesMap.get(league);\n    }\n\n    /**\n     * Returns the list of player entries after filtering by PlayerDetail.\n     *\n     * @param listPlayerEntries the list of player entries used as input for this filtering by PlayerDetail\n     * @param playerDetail the PlayerDetail to retrieve\n     * @param name the name of the PlayerDetail to retrieve\n     * @return List<PlayerEntry>, a </PlayerEntry> list with the relevant player entries\n     */\n    public List<PlayerEntry> getPlayerEntriesList(List<PlayerEntry> listPlayerEntries,\n                                                  PlayerDetail playerDetail,\n                                                  String name) {\n        if (name.equals(\"\")) return listPlayerEntries;\n\n        List<String> listPlayerNames =\n                listPlayerEntries.stream().map(PlayerEntry::getPlayerName).collect(Collectors.toList());\n        listPlayerEntries  = listPlayerEntries.stream()\n                .filter(w -> w.getDetail(playerDetail).equals(name)).collect(Collectors.toList());\n\n        return listPlayerEntries;\n    }\n\n    /**\n     * getPlayerEntriesCount method - returns how many player entries of the given type are stored\n     *\n     * @param league Either Premier League, La Liga or all\n     * @return number of player entries held of type <code>league</code>\n     */\n    public int getPlayerEntriesCount(League league) {\n        List<PlayerEntry> list = getPlayerEntriesList(league);\n        return list.size(); // list should never be null\n    }\n\n    /**\n     * getNumberUniquePlayers method - returns how many UNIQUE players of the given type are stored\n     *\n     * @param league Either Premier League, La Liga or all\n     * @return number of UNIQUE players held of type <code>league</code>\n     */\n    public int getNumberUniquePlayers(League league) {\n        List<PlayerEntry> list = getPlayerEntriesList(league);\n        List<String> listPlayerNames =\n                list.stream().map(PlayerEntry::getPlayerName).distinct().collect(Collectors.toList());\n        return listPlayerNames.size(); // listPlayerNames should never be null\n\n    }\n\n    /**\n     * Get the minimum value of the given property for player entries in this league in this player catalog\n     * @param playerProperty the property to evaluate\n     * @param league the League to use\n     * @return the minimum value of the property\n     */\n    public double getMinimumValue(PlayerProperty playerProperty, League league) {\n        return getMinimumValue(playerProperty, getPlayerEntriesList(league));\n    }\n\n    /**\n     * Get the maximum value of the given property for player entries in this league in this player catalog.\n     *\n     * @param playerProperty the property to evaluate\n     * @param league the League to use\n     * @return the maximum value of the property\n     */\n    public double getMaximumValue(PlayerProperty playerProperty, League league) {\n        return getMaximumValue(playerProperty, getPlayerEntriesList(league));\n    }\n\n    /**\n     * Get the mean value of the given property for player entries in this league in this player catalog.\n     *\n     * @param playerProperty the property to evaluate\n     * @param league the League to use\n     * @return the mean measurement of the property\n     */\n    public double getMeanAverageValue(PlayerProperty playerProperty, League league) {\n        return getMeanAverageValue(playerProperty, getPlayerEntriesList(league));\n    }\n\n    /**\n     * Get the minimum value of the given property for the specified player entries.\n     * Note: these player entries do not necessarily belong to the current catalog.\n     *\n     * @param playerProperty the property to evaluate\n     * @param playerEntryList the list of player entries to check\n     * @return the minimum value of the property present in the specified player entries\n     * @throws NoSuchElementException if there are no minimum values for the property, because playerEntryList is invalid\n     */\n    public abstract double getMinimumValue(PlayerProperty playerProperty, List<PlayerEntry> playerEntryList)\n            throws NoSuchElementException;\n\n    /**\n     * Get the maximum value of the given property for the specified player entries.\n     * Note: these player entries do not necessarily belong to the current catalog.\n     *\n     * @param playerProperty the property to evaluate\n     * @param playerEntryList the player entries to check\n     * @return the maximum value of the property present in the specified player entries\n     * @throws NoSuchElementException if there are no maximum values for the property, because playerEntryList is invalid\n     */\n    public abstract double getMaximumValue(PlayerProperty playerProperty, List<PlayerEntry> playerEntryList)\n            throws NoSuchElementException;\n\n    /**\n     * Get the mean value of the given property for the specified player entries.\n     * Note: these player entries do not necessarily belong to the current catalog.\n     *\n     * @param playerProperty the property to evaluate\n     * @param playerEntryList the player entries to check\n     * @return the mean value of the property present in the specified player entries\n     * @throws NoSuchElementException if there are no maximum values for the property, because playerEntryList is invalid\n     */\n    public abstract double getMeanAverageValue(PlayerProperty playerProperty, List<PlayerEntry> playerEntryList)\n            throws NoSuchElementException;\n\n    /**\n     * Get the first 5 player entries in the given league.\n     *\n     * @param type the League to get the first player entries\n     * @return a List of the first 5 player entries of the given type\n     */\n    public abstract List<PlayerEntry> getFirstFivePlayerEntries(League type);\n}\n\n/* Comment generated by Gradeer\n==============\nQueryParser.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment;\n\nimport uk.ac.sheffield.com1003.assignment.codeprovided.*;\nimport java.util.*;\n\n/**\n * SKELETON IMPLEMENTATION\n */\npublic class QueryParser extends AbstractQueryParser\n{\n\n    // Default implementation to be provided\n    @Override\n    public List<Query> readQueries(List<String> queryTokens) throws IllegalArgumentException {\n        List<Query> queriesList = new ArrayList<>();\n        List<SubQuery> subQueriesList = new ArrayList<>();\n        League leagueType;\n        PlayerProperty playerProperty;\n        String operator;\n        double value;\n\n        ListIterator<String> iterator = queryTokens.listIterator();\n        String token = iterator.next();\n\n        // Create the Query objects for each query\n        while (iterator.hasNext()) {\n            try {\n                if (token.equals(\"select\")) {\n                    token = iterator.next();\n                } else {\n                    throw new IllegalArgumentException(\"The query must start with 'select'.\");\n                }\n                if (token.equals(\"epl\") || token.equals(\"liga\")) {\n                    String league = token;\n                    token = iterator.next();\n                    if (token.equals(\"or\")) {\n                        token = iterator.next();\n                        if (token.equals(\"epl\") || token.equals(\"liga\")) {\n                            leagueType = League.ALL;\n                            token = iterator.next();\n                        } else {\n                            throw new IllegalArgumentException\n                                (\"Invalid league specified in 'or' clause.\");\n                        }\n                    } else if (token.equals(\"where\")) {\n                        leagueType = League.valueOf(league.toUpperCase());\n                    } else {\n                        throw new IllegalArgumentException\n                            (\"Invalid syntax after league specified.\");\n                    }\n                } else {\n                    throw new IllegalArgumentException(\"Invalid league specified.\");\n                }\n                if (token.equals(\"where\")) {\n                    token = iterator.next();\n                } else {\n                    throw new IllegalArgumentException(\"Missing 'where' clause.\");\n                }\n                // Create the SubQuery objects for each query\n                while (iterator.hasNext()) {\n                    if (token.equals(\"select\")) {\n                        break;\n                    }\n                    if (token.equals(\"and\")) {\n                        token = iterator.next();\n                    }\n                    if (isValidPlayerProperty(token)) {\n                        playerProperty = PlayerProperty.valueOf(token.toUpperCase());\n                        token = iterator.next();\n                    } else {\n                        throw new IllegalArgumentException(\"Invalid player property specified.\");\n                    }\n                    if (SubQuery.isValidOperator(token)) {\n                        operator = token;\n                        token = iterator.next();\n                    } else {\n                        throw new IllegalArgumentException(\"Invalid operator specified.\");\n                    }\n                    if (Double.valueOf(token) instanceof Double && Double.valueOf(token) >= 0) {\n                        value = Double.valueOf(token);\n                    } else {\n                        throw new IllegalArgumentException(\"Invalid value specified.\");\n                    }\n                    SubQuery subQuery = new SubQuery(playerProperty, operator, value);\n                    subQueriesList.add(subQuery);\n                    if (iterator.hasNext()) {\n                        token = iterator.next();\n                    } else {\n                        break;\n                    }\n                }\n\n                Query query = new Query(subQueriesList, leagueType);\n                queriesList.add(query);\n                subQueriesList = new ArrayList<>();\n            } catch (IllegalArgumentException e) {\n                // Ignore this query and continue reading the rest of the queries\n                subQueriesList = new ArrayList<>();\n                while (iterator.hasNext()) {\n                    token = iterator.next();\n                    if (token.equals(\"select\")) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return queriesList;\n    }\n\n    /**\n     * Check if the given string is a valid player property enum.\n     * \n     * @param playerPropertyToCheck the string to check\n     * @return true if the string is a valid player property enum; false otherwise\n     */\n    private boolean isValidPlayerProperty(String playerPropertyToCheck) {\n        for (PlayerProperty p : PlayerProperty.values()) {\n            if (p.name().equals(playerPropertyToCheck.toUpperCase())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n}\n\n/* Comment generated by Gradeer\n==============\nPlayerDashboardPanel.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment.gui;\n\nimport uk.ac.sheffield.com1003.assignment.codeprovided.*;\nimport uk.ac.sheffield.com1003.assignment.codeprovided.gui.AbstractPlayerDashboardPanel;\n\nimport java.awt.Font;\nimport java.awt.event.ActionListener;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.stream.Collectors;\n\nimport javax.swing.*;\n\n/**\n * SKELETON IMPLEMENTATION\n */\n\npublic class PlayerDashboardPanel extends AbstractPlayerDashboardPanel\n{\n\n    // Constructor\n    public PlayerDashboardPanel(AbstractPlayerCatalog playerCatalog) {\n        super(playerCatalog);\n    }\n\n    @Override\n    public void populatePlayerDetailsComboBoxes() {\n        playerNamesList.clear();\n        nationList.clear();\n        positionList.clear();\n        teamList.clear();\n\n        comboPlayerNames.removeAllItems();\n        comboNations.removeAllItems();\n        comboPositions.removeAllItems();\n        comboTeams.removeAllItems();\n    \n        // Populate the combo boxes with the appropriate player details\n        for (PlayerEntry entry : filteredPlayerEntriesList) {\n            String name = entry.getPlayerName();\n            String nation = entry.getNation();\n            String position = entry.getPosition();\n            String team = entry.getTeam();\n            if ((name.equals(selectedPlayerName) || selectedPlayerName.equals(\"\")) &&\n                    (nation.equals(selectedPlayerNation) || selectedPlayerNation.equals\n                    (\"\")) && (position.equals(selectedPlayerPosition) || \n                    selectedPlayerPosition.equals(\"\")) && (team.equals(selectedTeam) || \n                    selectedTeam.equals(\"\"))) {\n                if (!playerNamesList.contains(name)) {\n                    playerNamesList.add(name);\n                }\n                if (!nationList.contains(nation)) {\n                    nationList.add(nation);\n                }\n                if (!positionList.contains(position)) {\n                    positionList.add(position);\n                }\n                if (!teamList.contains(team)) {\n                    teamList.add(team);\n                }\n            }\n        }\n\n        // Retrieve the models for each combo box\n        DefaultComboBoxModel<String> modelPlayerNames = (DefaultComboBoxModel<String>) \n            comboPlayerNames.getModel();\n        DefaultComboBoxModel<String> modelNations = (DefaultComboBoxModel<String>) \n            comboNations.getModel();\n        DefaultComboBoxModel<String> modelPositions = (DefaultComboBoxModel<String>) \n            comboPositions.getModel();\n        DefaultComboBoxModel<String> modelTeams = (DefaultComboBoxModel<String>) \n            comboTeams.getModel();\n\n        playerNamesList.add(0,\"\");\n        nationList.add(0,\"\");\n        positionList.add(0,\"\");\n        teamList.add(0,\"\");\n\n        // Add the corresponding lists to the models\n        modelPlayerNames.addAll(playerNamesList);\n        modelNations.addAll(nationList);\n        modelPositions.addAll(positionList);\n        modelTeams.addAll(teamList);\n\n        // Set the selected items to the previously selected values\n        modelPlayerNames.setSelectedItem(selectedPlayerName);\n        modelNations.setSelectedItem(selectedPlayerNation);\n        modelPositions.setSelectedItem(selectedPlayerPosition);\n        modelTeams.setSelectedItem(selectedTeam);\n\n        updateStatistics();\n        updatePlayerCatalogDetailsBox();\n        updateRadarChart();\n    }\n\n    /**\n     * addListeners method - adds relevant actionListeners to the GUI components\n     */\n    @SuppressWarnings(\"unused\")\n    @Override\n    public void addListeners() {\n        buttonAddFilter.addActionListener(e -> {\n            removeListeners();\n            addFilter();\n            executeQuery();\n            populatePlayerDetailsComboBoxes();\n            addListeners();\n        });\n\n        buttonClearFilters.addActionListener(e -> {\n            removeListeners();\n            clearFilters();\n            executeQuery();\n            populatePlayerDetailsComboBoxes();\n            addListeners();\n        });\n\n        comboLeagueTypes.addActionListener(e -> {\n            removeListeners();\n            if ((comboLeagueTypes.getSelectedItem()).equals(\"English Premier League\"))\n                selectedLeagueType = League.EPL;\n            else if ((comboLeagueTypes.getSelectedItem()).equals(\"La Liga\"))\n                selectedLeagueType = League.LIGA;\n            else\n                selectedLeagueType = League.ALL;\n            executeQuery();\n            populatePlayerDetailsComboBoxes();\n            addListeners();\n        });\n\n        comboPlayerNames.addActionListener(e -> {\n            removeListeners();\n            selectedPlayerName = comboPlayerNames.getSelectedItem().toString();\n            executeQuery();\n            populatePlayerDetailsComboBoxes();\n            addListeners();\n        });\n\n        comboNations.addActionListener(e -> {\n            removeListeners();\n            selectedPlayerNation = comboNations.getSelectedItem().toString();\n            executeQuery();\n            populatePlayerDetailsComboBoxes();\n            addListeners();\n        });\n\n        comboPositions.addActionListener(e -> {\n            removeListeners();\n            selectedPlayerPosition = comboPositions.getSelectedItem().toString();\n            executeQuery();\n            populatePlayerDetailsComboBoxes();\n            addListeners();\n        });\n\n        comboTeams.addActionListener(e -> {\n            removeListeners();\n            selectedTeam = comboTeams.getSelectedItem().toString();\n            executeQuery();\n            populatePlayerDetailsComboBoxes();\n            addListeners();\n        });\n\n        comboRadarChartCategories.addActionListener(e -> {\n            removeListeners();\n            updateRadarChart();\n            addListeners();\n        });\n\n        minCheckBox.addActionListener(e -> {\n            removeListeners();\n            updateRadarChart();\n            addListeners();\n        });\n\n        maxCheckBox.addActionListener(e -> {\n            removeListeners();\n            updateRadarChart();\n            addListeners();\n        });\n\n        averageCheckBox.addActionListener(e -> {\n            removeListeners();\n            updateRadarChart();\n            addListeners();\n        });\n    }\n\n    /**\n     * removeListeners method - a helper method that removes relevant actionListeners from the GUI \n     * components\n     */\n    public void removeListeners() {\n        for (ActionListener aListener : buttonAddFilter.getActionListeners()) {\n            buttonAddFilter.removeActionListener(aListener);\n        }\n        for (ActionListener aListener : buttonClearFilters.getActionListeners()) {\n            buttonClearFilters.removeActionListener(aListener);\n        }\n        for (ActionListener aListener : comboLeagueTypes.getActionListeners()) {\n            comboLeagueTypes.removeActionListener(aListener);\n        }\n        for (ActionListener aListener : comboPlayerNames.getActionListeners()) {\n            comboPlayerNames.removeActionListener(aListener);\n        }\n        for (ActionListener aListener : comboNations.getActionListeners()) {\n            comboNations.removeActionListener(aListener);\n        }\n        for (ActionListener aListener : comboPositions.getActionListeners()) {\n            comboPositions.removeActionListener(aListener);\n        }\n        for (ActionListener aListener : comboTeams.getActionListeners()) {\n            comboTeams.removeActionListener(aListener);\n        }\n        for (ActionListener aListener : comboRadarChartCategories.getActionListeners()) {\n            comboRadarChartCategories.removeActionListener(aListener);\n        }\n        for (ActionListener aListener : minCheckBox.getActionListeners()) {\n            minCheckBox.removeActionListener(aListener);\n        }\n        for (ActionListener aListener : maxCheckBox.getActionListeners()) {\n            maxCheckBox.removeActionListener(aListener);\n        }\n        for (ActionListener aListener : averageCheckBox.getActionListeners()) {\n            averageCheckBox.removeActionListener(aListener);\n        }\n    }\n\n    /**\n     * clearFilters method - clears all filters from the subQueryList ArrayList and updates\n     * the relevant GUI components\n     */\n    @Override\n    public void clearFilters() {\n        subQueryList.clear();\n        subQueriesTextArea.setText(\"\");\n\n        selectedLeagueType = League.ALL;\n        selectedPlayerName = \"\";\n        selectedPlayerNation = \"\";\n        selectedPlayerPosition = \"\";\n        selectedTeam = \"\";\n\n        comboLeagueTypes.setSelectedIndex(0);\n        comboPlayerNames.setSelectedIndex(0);\n        comboNations.setSelectedIndex(0);\n        comboPositions.setSelectedIndex(0);\n        comboTeams.setSelectedIndex(0);\n\n        comboQueryProperties.setSelectedIndex(0);\n        comboOperators.setSelectedItem(operators[0]);\n        value.setText(\"\");\n    }\n\n    @Override\n    public void updateRadarChart() {\n        Category category = Category.getCategoryFromName\n            (comboRadarChartCategories.getSelectedItem().toString());\n\n        List<PlayerProperty> categoryProperties = Arrays.asList(category.getProperties());\n\n        radarChart.updateRadarChartContents(categoryProperties, filteredPlayerEntriesList);\n\n        repaint();\n    }\n\n    /**\n     * updateStats method - updates the table with statistics after any changes which may\n     * affect the JTable which holds the statistics\n     */\n    @Override\n    public void updateStatistics() {\n        statisticsTextArea.setText(\"\");\n        statisticsTextArea.setFont(new Font(\"Monospaced\", Font.PLAIN, 12));\n\n        // Add column headers to statisticsTextArea\n        for (PlayerProperty propertyName : PlayerProperty.values()) {\n            statisticsTextArea.append(\" \".repeat(52-propertyName.getName().length()) + \n                propertyName.getName());\n        }\n\n        // Add the minimum values to statisticsTextArea\n        statisticsTextArea.append(\"\n\" + \"Minimum:\" + \" \".repeat(43));\n        for (PlayerProperty propertyValue : PlayerProperty.values()) {\n            try {\n                double minimumProperty = playerCatalog.getMinimumValue\n                    (propertyValue, filteredPlayerEntriesList);\n\n                statisticsTextArea.append(String.valueOf(minimumProperty) + \n                    \" \".repeat(51-String.valueOf(minimumProperty).length()));\n            } catch (NoSuchElementException e) {\n                System.out.println(e.getMessage());\n            }\n        }\n\n        // Add the maximum values to statisticsTextArea\n        statisticsTextArea.append(\"\n\" + \"Maximum:\" + \" \".repeat(43));\n        for (PlayerProperty propertyValue : PlayerProperty.values()) {\n            try {\n                double maximumProperty = playerCatalog.getMaximumValue\n                    (propertyValue, filteredPlayerEntriesList);\n\n                statisticsTextArea.append(String.valueOf(maximumProperty) + \n                    \" \".repeat(51-String.valueOf(maximumProperty).length()));\n            } catch (NoSuchElementException e) {\n                System.out.println(e.getMessage());\n            }\n        }\n\n        // Add the mean values to statisticsTextArea\n        statisticsTextArea.append(\"\n\" + \"Mean:\" + \" \".repeat(46));\n        for (PlayerProperty propertyValue : PlayerProperty.values()) {\n            try {\n                double meanProperty = playerCatalog.getMeanAverageValue\n                    (propertyValue, filteredPlayerEntriesList);\n\n                statisticsTextArea.append(String.format(\"%.2f\", meanProperty) + \n                    \" \".repeat(51 - String.format(\"%.2f\", meanProperty).length()));\n            } catch (NoSuchElementException e) {\n                System.out.println(e.getMessage());\n            }\n        }\n\n        statisticsTextArea.setCaretPosition(0);\n    }\n\n    /**\n     * updatePlayerCatalogDetailsBox method - updates the list of players when changes are made\n     */\n    @Override\n    public void updatePlayerCatalogDetailsBox() {\n        filteredPlayerEntriesTextArea.setText(\"\");\n        filteredPlayerEntriesTextArea.setFont(new Font(\"Monospaced\", Font.PLAIN, 12));\n\n        // Add the column headers to filteredPlayerEntriesTextArea\n        filteredPlayerEntriesTextArea.append(\"League Type\" + \" \".repeat\n            (41) + \"ID\" + \" \".repeat(52));\n        for (PlayerDetail propertyName : PlayerDetail.values()) {\n            filteredPlayerEntriesTextArea.append\n                (propertyName.getName() + \" \".repeat(52-propertyName.getName().length()));\n        }\n        for (PlayerProperty propertyName : PlayerProperty.values()) {\n            filteredPlayerEntriesTextArea.append\n                (propertyName.getName() + \" \".repeat(52-propertyName.getName().length()));\n        }\n\n        filteredPlayerEntriesTextArea.append(\"\n\");\n\n        // Add the player entries to filteredPlayerEntriesTextArea\n        for (PlayerEntry entry : filteredPlayerEntriesList) {\n            String leagueType = entry.getLeagueType().getName();\n            String id = String.valueOf(entry.getId());\n            String playerName = entry.getPlayerName();\n            String nation = entry.getNation();\n            String position = entry.getPosition();\n            String team = entry.getTeam();\n\n            filteredPlayerEntriesTextArea.append(leagueType + \" \".repeat(52-leagueType.length()) + \n                id + \" \".repeat(52-id.length()) + playerName + \n                \" \".repeat(52-playerName.length()) + nation + \" \".repeat(52-nation.length()) + \n                position + \" \".repeat(52-position.length()) + team + \" \".repeat(52-team.length()));\n\n            for (PlayerProperty propertyValue : PlayerProperty.values()) {\n                filteredPlayerEntriesTextArea.append(String.valueOf(entry.getProperty\n                    (propertyValue)) + \" \".repeat(52-String.valueOf(entry.getProperty\n                    (propertyValue)).length()));\n            }\n\n            filteredPlayerEntriesTextArea.append(\"\n\");\n        }\n\n        filteredPlayerEntriesTextArea.setCaretPosition(0);\n    }\n\n    /**\n     * executeQuery method - applies chosen query to the relevant list\n     */\n    @Override\n    public void executeQuery() {\n        if ((comboLeagueTypes.getSelectedItem()).equals(\"English Premier League\"))\n            selectedLeagueType = League.EPL;\n        else if ((comboLeagueTypes.getSelectedItem()).equals(\"La Liga\"))\n            selectedLeagueType = League.LIGA;\n        else\n            selectedLeagueType = League.ALL;\n\n        Query queryToBeExecuted = new Query(subQueryList,selectedLeagueType);\n        filteredPlayerEntriesList = queryToBeExecuted.executeQuery(playerCatalog);\n\n        // Filter by player name if selected\n        if (!selectedPlayerName.equals(\"\")) {\n            filteredPlayerEntriesList = filteredPlayerEntriesList.stream()\n                    .filter(entry -> entry.getPlayerName().equals(selectedPlayerName))\n                    .collect(Collectors.toList());\n        }\n\n        // Filter by nation if selected\n        if (!selectedPlayerNation.equals(\"\")) {\n            filteredPlayerEntriesList = filteredPlayerEntriesList.stream()\n                    .filter(entry -> entry.getNation().equals(selectedPlayerNation))\n                    .collect(Collectors.toList());\n        }\n\n        // Filter by position if selected\n        if (!selectedPlayerPosition.equals(\"\")) {\n            filteredPlayerEntriesList = filteredPlayerEntriesList.stream()\n                    .filter(entry -> entry.getPosition().equals(selectedPlayerPosition))\n                    .collect(Collectors.toList());\n        }\n\n        // Filter by team if selected\n        if (!selectedTeam.equals(\"\")) {\n            filteredPlayerEntriesList = filteredPlayerEntriesList.stream()\n                    .filter(entry -> entry.getTeam().equals(selectedTeam))\n                    .collect(Collectors.toList());\n        }\n\n        populatePlayerDetailsComboBoxes();\n    }\n\n    /**\n     * addFilters method - adds filters input into GUI to subQueryList ArrayList\n     */\n    @Override\n    public void addFilter() {\n        PlayerProperty playerProperty = PlayerProperty.fromPropertyName\n            (comboQueryProperties.getSelectedItem().toString());\n        String operator = comboOperators.getSelectedItem().toString();\n        double number;\n\n        // Create a new SubQuery object\n        try {\n            if (Double.valueOf(value.getText()) >= 0)\n                number = Double.valueOf(value.getText());\n            else\n                return;\n        } catch (NumberFormatException e) {\n            return;\n        }\n        SubQuery subQueryToBeAdded = new SubQuery(playerProperty, operator, number);\n\n        // Add the new SubQuery object to subQueryList\n        for (SubQuery subQuery : subQueryList) {\n            if (subQuery.equals(subQueryToBeAdded)) {\n                return;\n            }\n        }\n        subQueryList.add(subQueryToBeAdded);\n\n        subQueriesTextArea.append(subQueryToBeAdded.toString() + \"; \");\n    }\n\n    @Override\n    public boolean isMinCheckBoxSelected() {\n        return minCheckBox.isSelected();\n    }\n\n    @Override\n    public boolean isMaxCheckBoxSelected() {\n        return maxCheckBox.isSelected();\n    }\n\n    @Override\n    public boolean isAverageCheckBoxSelected() {\n        return averageCheckBox.isSelected();\n    }\n\n}\n\n/* Comment generated by Gradeer\n==============\nRadarChart.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment.gui;\n\nimport uk.ac.sheffield.com1003.assignment.codeprovided.AbstractPlayerCatalog;\nimport uk.ac.sheffield.com1003.assignment.codeprovided.PlayerEntry;\nimport uk.ac.sheffield.com1003.assignment.codeprovided.PlayerProperty;\nimport uk.ac.sheffield.com1003.assignment.codeprovided.gui.AbstractRadarChart;\nimport uk.ac.sheffield.com1003.assignment.codeprovided.gui.RadarAxisValues;\n\nimport java.util.*;\n\n/**\n * SKELETON IMPLEMENTATION\n */\n\npublic class RadarChart extends AbstractRadarChart\n{\n    public RadarChart(AbstractPlayerCatalog playerCatalog, List<PlayerEntry> filteredPlayerEntriesList,\n                      List<PlayerProperty> playerRadarChartProperties)\n    {\n        super(playerCatalog, filteredPlayerEntriesList, playerRadarChartProperties);\n    }\n\n    @Override\n    public void updateRadarChartContents(List<PlayerProperty> radarChartPlayerProperties,\n                                         List<PlayerEntry> filteredPlayerEntriesList) {\n        this.playerRadarChartProperties = radarChartPlayerProperties;\n        this.filteredPlayerEntries = filteredPlayerEntriesList;\n\n        radarAxesValues.clear();\n\n        // Get the minimum, maximum and mean values of the player properties\n        for (PlayerProperty property : radarChartPlayerProperties) {\n            double minimumValue = getPlayerCatalog().getMinimumValue\n                (property, filteredPlayerEntriesList);\n            double maximumValue = getPlayerCatalog().getMaximumValue\n                (property, filteredPlayerEntriesList);\n            double meanValue = getPlayerCatalog().getMeanAverageValue\n                (property, filteredPlayerEntriesList);\n\n            // Store the axis values in radarAxesValues with the PlayerProperty as the key\n            RadarAxisValues radarAxisValues = new RadarAxisValues\n                (minimumValue, maximumValue, meanValue);\n            radarAxesValues.put(property, radarAxisValues);\n        }\n    }\n\n    @Override\n    public List<PlayerProperty> getPlayerRadarChartProperties() throws NoSuchElementException {\n        return playerRadarChartProperties;\n    }\n\n    @Override\n    public Map<PlayerProperty, RadarAxisValues> getRadarPlotAxesValues() throws NoSuchElementException {\n        return radarAxesValues;\n    }\n\n    @Override\n    public AbstractPlayerCatalog getPlayerCatalog() {\n        return playerCatalog;\n    }\n\n    @Override\n    public List<PlayerEntry> getFilteredPlayerEntries() {\n        return filteredPlayerEntries;\n    }\n\n}\n\n/* Comment generated by Gradeer\n==============\nRadarChartPanel.java\n==============\n*/\n\npackage uk.ac.sheffield.com1003.assignment.gui;\n\nimport uk.ac.sheffield.com1003.assignment.codeprovided.gui.AbstractRadarChart;\nimport uk.ac.sheffield.com1003.assignment.codeprovided.gui.AbstractRadarChartPanel;\nimport uk.ac.sheffield.com1003.assignment.codeprovided.gui.RadarAxisValues;\nimport uk.ac.sheffield.com1003.assignment.codeprovided.League;\nimport uk.ac.sheffield.com1003.assignment.codeprovided.PlayerProperty;\nimport uk.ac.sheffield.com1003.assignment.codeprovided.gui.AbstractPlayerDashboardPanel;\n\nimport java.awt.*;\nimport java.util.List;\nimport java.util.Map;\nimport java.awt.geom.Line2D;\nimport java.util.ArrayList;\n\n/**\n * SKELETON IMPLEMENTATION\n */\n\npublic class RadarChartPanel extends AbstractRadarChartPanel\n{\n    public RadarChartPanel(AbstractPlayerDashboardPanel parentPanel, AbstractRadarChart radarPlot) {\n        super(parentPanel, radarPlot);\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Dimension d = getSize();\n        Graphics2D g2 = (Graphics2D) g;\n\n        // Calculate the centre point of the panel\n        int centerX = d.width / 2;\n        int centerY = d.height / 2;\n\n        // Define the length of the pentagon's sides as a fraction of the panel's width\n        double sideLength = 0.3 * d.width;\n\n        // Draw the main pentagon\n        Point[] mainPoints = new Point[5];\n\n        for (int i = 0; i < 5; i++) {\n            double angle = Math.toRadians(72 * i - 18);\n            int x = (int) (centerX + sideLength * Math.cos(angle));\n            int y = (int) (centerY - sideLength * Math.sin(angle));\n            mainPoints[i] = new Point(x, y);\n        }\n\n        g2.draw(new Line2D.Double(mainPoints[0], mainPoints[1]));\n        g2.draw(new Line2D.Double(mainPoints[1], mainPoints[2]));\n        g2.draw(new Line2D.Double(mainPoints[2], mainPoints[3]));\n        g2.draw(new Line2D.Double(mainPoints[3], mainPoints[4]));\n        g2.draw(new Line2D.Double(mainPoints[4], mainPoints[0]));\n\n        // Draw the smaller pentagons inside the main pentagon\n        double k = 0.25;\n        for (int j = 1; j < 4; j++) {\n            // the length of the side of the j-th pentagon\n            double smallerSideLength = k * sideLength * j;\n            Point[] smallerPoints = new Point[5];\n\n            for (int i = 0; i < 5; i++) {\n                double angle = Math.toRadians(72 * i - 18);\n                int x = (int) (centerX + smallerSideLength * Math.cos(angle));\n                int y = (int) (centerY - smallerSideLength * Math.sin(angle));\n                smallerPoints[i] = new Point(x, y);\n            }\n\n            g2.draw(new Line2D.Double(smallerPoints[0], smallerPoints[1]));\n            g2.draw(new Line2D.Double(smallerPoints[1], smallerPoints[2]));\n            g2.draw(new Line2D.Double(smallerPoints[2], smallerPoints[3]));\n            g2.draw(new Line2D.Double(smallerPoints[3], smallerPoints[4]));\n            g2.draw(new Line2D.Double(smallerPoints[4], smallerPoints[0]));\n        }\n\n        int radius = Math.min(centerX, centerY) - 10;\n\n        List<PlayerProperty> properties = getRadarChart().getPlayerRadarChartProperties();\n        Map<PlayerProperty, RadarAxisValues> radarAxisValues = getRadarChart().\n            getRadarPlotAxesValues();\n\n        // Calculate the coordinates for each vertex label\n        List<Point> labelPoints = new ArrayList<>();\n        for (int i = 0; i < 5; i++) {\n            double angle = Math.toRadians(72 * i - 18);\n            int x = (int) Math.round(centerX + radius * Math.cos(angle));\n            int y = (int) Math.round(centerY - radius * Math.sin(angle));\n            labelPoints.add(new Point(x, y));\n        }\n\n        // Draw the labels for the vertices\n        Font font = g.getFont().deriveFont(Font.BOLD, 12f);\n        FontMetrics metrics = g.getFontMetrics(font);\n        g.setFont(font);\n        for (int i = 0; i < 5; i++) {\n            String label = properties.get(i).toString();\n            Point labelPoint = labelPoints.get(i);\n            int labelX = labelPoint.x - metrics.stringWidth(label) / 2;\n            int labelY = labelPoint.y + metrics.getHeight() / 2;\n            g.drawString(label, labelX, labelY);\n        }\n\n        // Find the scale values for each player property\n        double[] scaleValues = new double[5];\n        for (int i = 0; i < 5; i++) {\n            PlayerProperty playerProperty = properties.get(i);\n            double maxValue = getRadarChart().getPlayerCatalog().getMaximumValue\n                (playerProperty, League.ALL);\n            scaleValues[i] = maxValue;\n        }\n\n        if (getParentPanel().isMinCheckBoxSelected()) {\n            // Set the colour to blue\n            g2.setColor(new Color(0, 0, 255, 100));\n            Point[] minPoints = new Point[5];\n\n            // Calculate the coordinates for each vertex of the minimum polygon\n            for (int i = 0; i < 5; i++) {\n                double minimumValue = radarAxisValues.get(properties.get(i)).getMin();\n                double value = minimumValue / scaleValues[i] * radius;\n\n                double angle = Math.toRadians(72 * i - 18);\n                int x = (int) Math.round(centerX + value * Math.cos(angle));\n                int y = (int) Math.round(centerY - value * Math.sin(angle));\n\n                minPoints[i] = new Point(x, y);\n            }\n\n            // Fill the minimum polygon\n            g2.fillPolygon(new Polygon(\n                new int[] { minPoints[0].x, minPoints[1].x, minPoints[2].x, minPoints[3].x, \n                    minPoints[4].x },\n                new int[] { minPoints[0].y, minPoints[1].y, minPoints[2].y, minPoints[3].y, \n                    minPoints[4].y },\n                5\n            ));\n        }\n\n        if (getParentPanel().isMaxCheckBoxSelected()) {\n            // Set the colour to red\n            g2.setColor(new Color(255, 0, 0, 100));\n            Point[] maxPoints = new Point[5];\n\n            // Calculate the coordinates for each vertex of the maximum polygon\n            for (int i = 0; i < 5; i++) {\n                double maximumValue = radarAxisValues.get(properties.get(i)).getMax();\n                double value = maximumValue / scaleValues[i] * radius;\n            \n                double angle = Math.toRadians(72 * i - 18);\n                int x = (int) Math.round(centerX + value * Math.cos(angle));\n                int y = (int) Math.round(centerY - value * Math.sin(angle));\n\n                maxPoints[i] = new Point(x, y);\n            }\n\n            // Fill the maximum polygon\n            g2.fillPolygon(new Polygon(\n                new int[] { maxPoints[0].x, maxPoints[1].x, maxPoints[2].x, maxPoints[3].x, \n                    maxPoints[4].x },\n                new int[] { maxPoints[0].y, maxPoints[1].y, maxPoints[2].y, maxPoints[3].y, \n                    maxPoints[4].y },\n                5\n            ));\n        }\n\n        if (getParentPanel().isAverageCheckBoxSelected()) {\n            // Set the colour to green\n            g2.setColor(new Color(0, 255, 0, 100));\n            Point[] meanPoints = new Point[5];\n\n            // Calculate the coordinates for each vertex of the average polygon\n            for (int i = 0; i < 5; i++) {\n                double meanValue = radarAxisValues.get(properties.get(i)).getAverage();\n                double value = meanValue / scaleValues[i] * radius;\n\n                double angle = Math.toRadians(72 * i - 18);\n                int x = (int) Math.round(centerX + value * Math.cos(angle));\n                int y = (int) Math.round(centerY - value * Math.sin(angle));\n\n                meanPoints[i] = new Point(x, y);\n            }\n\n            // Fill the average polygon\n            g2.fillPolygon(new Polygon(\n                new int[] { meanPoints[0].x, meanPoints[1].x, meanPoints[2].x, meanPoints[3].x, \n                    meanPoints[4].x },\n                new int[] { meanPoints[0].y, meanPoints[1].y, meanPoints[2].y, meanPoints[3].y, \n                    meanPoints[4].y },\n                5\n            ));\n        }\n    }\n\n}\n\n"}